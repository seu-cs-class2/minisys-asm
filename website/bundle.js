/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./package/entry/browser.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./package/assembler.ts":
/*!******************************!*\
  !*** ./package/assembler.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys汇编器 - 汇编代码解析\r\n * by Withod, z0gSh1u @ 2020-10\r\n * // TODO: 支持宏指令\r\n */\r\nvar __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.assemble = exports.parseOneLine = exports.getPC = exports.getLabelAddr = exports.getVarAddr = exports.TextSeg = exports.DataSeg = void 0;\r\nvar instruction_1 = __webpack_require__(/*! ./instruction */ \"./package/instruction.ts\");\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./package/utils.ts\");\r\n// 仿照如下形式来添加新的变量类型\r\n// prettier-ignore\r\nvar __VarCompType = {\r\n    byte: void 0, half: void 0, word: void 0, ascii: void 0, space: void 0\r\n};\r\nvar VarCompTypeRegex = Object.keys(__VarCompType).join('|');\r\n/**\r\n * 数据段\r\n */\r\nvar DataSeg = /** @class */ (function () {\r\n    function DataSeg(startAddr, vars) {\r\n        this._startAddr = startAddr;\r\n        this._vars = Array.from(vars);\r\n    }\r\n    Object.defineProperty(DataSeg.prototype, \"startAddr\", {\r\n        get: function () {\r\n            return this._startAddr;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DataSeg.prototype, \"vars\", {\r\n        get: function () {\r\n            return this._vars;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * 添加新变量\r\n     */\r\n    DataSeg.prototype.newVar = function (name, comps, addr) {\r\n        utils_1.assert(this._vars.every(function (v) { return v.name !== name; }), '重复的变量名。');\r\n        this._vars.push({\r\n            name: name,\r\n            comps: comps,\r\n            addr: addr,\r\n        });\r\n    };\r\n    /**\r\n     * 添加新变量组分\r\n     */\r\n    DataSeg.prototype.newComp = function (name, comp) {\r\n        utils_1.assert(this._vars.some(function (v) { return v.name === name; }), '找不到该变量。');\r\n        this._vars[this._vars.findIndex(function (v) { return v.name === name; })].comps.push(comp);\r\n    };\r\n    return DataSeg;\r\n}());\r\nexports.DataSeg = DataSeg;\r\n/**\r\n * 代码段\r\n */\r\nvar TextSeg = /** @class */ (function () {\r\n    function TextSeg(startAddr, ins, labels) {\r\n        this._startAddr = startAddr;\r\n        this._ins = Array.from(ins);\r\n        this._labels = Array.from(labels);\r\n    }\r\n    Object.defineProperty(TextSeg.prototype, \"startAddr\", {\r\n        get: function () {\r\n            return this._startAddr;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TextSeg.prototype, \"ins\", {\r\n        get: function () {\r\n            return this._ins;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TextSeg.prototype, \"labels\", {\r\n        get: function () {\r\n            return this._labels;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * 代码段二进制输出\r\n     */\r\n    TextSeg.prototype.toBinary = function () {\r\n        return this._ins.map(function (v) { return v.toBinary(); }).join('\\n');\r\n    };\r\n    return TextSeg;\r\n}());\r\nexports.TextSeg = TextSeg;\r\n// 分析过程辅助变量\r\nvar vars = [];\r\nvar labels = [];\r\nvar pc = 0;\r\n/**\r\n * 获取变量地址\r\n */\r\nfunction getVarAddr(name) {\r\n    var res = vars.find(function (v) { return v.name == name; });\r\n    utils_1.assert(res, \"\\u672A\\u77E5\\u7684\\u53D8\\u91CF\\uFF1A\" + name);\r\n    return res.addr;\r\n}\r\nexports.getVarAddr = getVarAddr;\r\n/**\r\n * 获取标签地址\r\n */\r\nfunction getLabelAddr(label) {\r\n    var res = labels.find(function (v) { return v.name == label; });\r\n    utils_1.assert(res, \"\\u672A\\u77E5\\u7684\\u6807\\u7B7E\\uFF1A\" + label);\r\n    return res.addr;\r\n}\r\nexports.getLabelAddr = getLabelAddr;\r\n/**\r\n * 获取PC地址\r\n */\r\nfunction getPC() {\r\n    return pc;\r\n}\r\nexports.getPC = getPC;\r\n/**\r\n * 解析数据段\r\n * @param asm 从.data开始，到.text的前一行\r\n */\r\nfunction parseDataSeg(asm) {\r\n    // 解析初始化值\r\n    // FIXME: ASCII转义、引号内带逗号处理\r\n    var parseInitValue = function (init) { return init.split(/\\s*,/).map(function (v) { return v.trim(); }); };\r\n    // 检查起始地址\r\n    var startAddr = asm[0].split(/\\s+/)[1] || '0';\r\n    utils_1.assert(asm[0].split(/\\s+/).length <= 2, '数据段首声明非法。');\r\n    // 变量声明开始正则\r\n    var VarStartPattern = new RegExp(String.raw(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"(.+):s+.(\", \")s+(.+)\"], [\"(.+):\\\\s+\\\\.(\", \")\\\\s+(.+)\"])), VarCompTypeRegex));\r\n    // 变量声明继续正则\r\n    var VarContdPattern = new RegExp(String.raw(templateObject_2 || (templateObject_2 = __makeTemplateObject([\".(\", \")s+(.+)\"], [\"\\\\.(\", \")\\\\s+(.+)\"])), VarCompTypeRegex));\r\n    var comps = [], name;\r\n    var i = 1;\r\n    var addr = Number(startAddr), nextAddr = addr;\r\n    vars = [];\r\n    var _loop_1 = function () {\r\n        if (VarStartPattern.test(asm[i])) {\r\n            // 一个新变量开始\r\n            if (name !== void 0) {\r\n                vars.push({\r\n                    name: name,\r\n                    comps: comps,\r\n                    addr: addr,\r\n                });\r\n                comps = [];\r\n                name = void 0;\r\n                addr = nextAddr;\r\n            }\r\n            name = RegExp.$1;\r\n            var type_1 = RegExp.$2;\r\n            var size_1 = utils_1.sizeof(type_1);\r\n            // 边界对齐\r\n            if (addr % size_1 > 0) {\r\n                nextAddr = addr = addr + size_1 - (addr % size_1);\r\n            }\r\n            // 推入组分记录\r\n            parseInitValue(RegExp.$3).forEach(function (val) {\r\n                comps.push({\r\n                    type: type_1,\r\n                    val: val,\r\n                });\r\n                // TODO: 确保val.length正确\r\n                nextAddr += size_1 * (type_1 === 'ascii' ? val.length : 1);\r\n            });\r\n        }\r\n        else if (VarContdPattern.test(asm[i])) {\r\n            // 变量组分继续\r\n            var type_2 = RegExp.$1;\r\n            var size_2 = utils_1.sizeof(type_2);\r\n            // 边界对齐，自动补.space\r\n            while (nextAddr % size_2 > 0) {\r\n                comps.push({\r\n                    type: 'space',\r\n                    val: '00',\r\n                });\r\n                nextAddr++;\r\n            }\r\n            // 推入组分记录\r\n            parseInitValue(RegExp.$2).forEach(function (val) {\r\n                comps.push({\r\n                    type: type_2,\r\n                    val: val,\r\n                });\r\n                nextAddr += size_2 * (type_2 === 'ascii' ? val.length : 1);\r\n            });\r\n        }\r\n        else {\r\n            // 报错\r\n            utils_1.assert(false, \"\\u672A\\u77E5\\u7684\\u53D8\\u91CF\\u5B9A\\u4E49\\u5F62\\u5F0F\\uFF0C\\u5728\\u6570\\u636E\\u6BB5\\u7B2C \" + (i + 1) + \" \\u884C\");\r\n        }\r\n        // 末尾处理\r\n        if (i === asm.length - 1) {\r\n            vars.push({\r\n                name: name,\r\n                comps: comps,\r\n                addr: addr,\r\n            });\r\n        }\r\n        i++;\r\n    };\r\n    // 开始扫描\r\n    do {\r\n        _loop_1();\r\n    } while (i < asm.length);\r\n    return new DataSeg(startAddr, vars);\r\n}\r\n/**\r\n * 解析代码段\r\n * @param asm .text起，到代码段结束\r\n */\r\nfunction parseTextSeg(asm_) {\r\n    var asm = Array.from(asm_);\r\n    // 确定数据段起始地址\r\n    var startAddr = asm[0].split(/\\s+/)[1] || '0';\r\n    utils_1.assert(asm[0].split(/\\s+/).length <= 2, '代码段首声明非法。');\r\n    // 起始地址校正到4字节对齐（32位）\r\n    var sizeofWord = utils_1.sizeof('word');\r\n    var startAddrNumber = Number(startAddr);\r\n    startAddr = String(((sizeofWord - (startAddrNumber % sizeofWord)) % sizeofWord) + startAddrNumber);\r\n    // pc指针\r\n    pc = utils_1.getOffsetAddr(startAddr, 0);\r\n    labels = [];\r\n    // 先提取掉所有的label\r\n    asm = asm.map(function (v, i) {\r\n        if (i === 0)\r\n            return v;\r\n        if (/(\\w+):\\s*(.+)/.test(v)) {\r\n            utils_1.assert(labels.every(function (label) { return label.name !== RegExp.$1; }), \"\\u5B58\\u5728\\u91CD\\u590D\\u7684label\\uFF1A\" + RegExp.$1);\r\n            labels.push({ name: RegExp.$1, lineno: i, addr: utils_1.getOffsetAddr(startAddr, utils_1.getOffset({ ins: i - 1 })) });\r\n            return RegExp.$2;\r\n        }\r\n        return v;\r\n    });\r\n    var ins = [];\r\n    asm.forEach(function (v, i) {\r\n        i !== 0 && ins.push(parseOneLine(v, i));\r\n    });\r\n    return new TextSeg(startAddr, ins, labels);\r\n}\r\n/**\r\n * 解析单行汇编到Instruction对象\r\n */\r\nfunction parseOneLine(asm, lineno) {\r\n    // 处理助记符\r\n    utils_1.assert(/^\\s*(\\w+)\\s+(.*)/.test(asm), \"\\u6CA1\\u6709\\u627E\\u5230\\u6307\\u4EE4\\u52A9\\u8BB0\\u7B26\\uFF0C\\u5728\\u4EE3\\u7801\\u6BB5\\u7B2C \" + lineno + \" \\u884C\\u3002\");\r\n    var symbol = RegExp.$1;\r\n    // 检验助记符合法性\r\n    var instructionIndex = instruction_1.MinisysInstructions.findIndex(function (x) { return x.symbol == symbol; });\r\n    utils_1.assert(instructionIndex !== -1, \"\\u6CA1\\u6709\\u627E\\u5230\\u6307\\u4EE4\\u52A9\\u8BB0\\u7B26\\uFF1A\" + symbol + \"\\uFF0C\\u5728\\u4EE3\\u7801\\u6BB5\\u7B2C \" + lineno + \" \\u884C\\u3002\");\r\n    // 单行汇编去空格\r\n    asm = utils_1.serialString(RegExp.$2);\r\n    // pc移进\r\n    pc += utils_1.sizeof('ins');\r\n    // 开始组装Instruction对象\r\n    var res = instruction_1.Instruction.newInstance(instruction_1.MinisysInstructions[instructionIndex]);\r\n    utils_1.assert(res.insPattern.test(asm), \"\\u4EE3\\u7801\\u6BB5\\u7B2C \" + lineno + \" \\u884C\\u6307\\u4EE4\\u53C2\\u6570\\u4E0D\\u5339\\u914D\\uFF1A\" + asm);\r\n    res.components.forEach(function (component) {\r\n        if (!component.val.trim() /* 代表是需要填充的变量，而不是指令二进制中的定值 */) {\r\n            try {\r\n                res.setComponent(component.desc, component.toBinary());\r\n            }\r\n            catch (err) {\r\n                err.message += \"\\uFF0C\\u5728\\u4EE3\\u7801\\u6BB5\\u7B2C \" + lineno + \" \\u884C\";\r\n                throw err;\r\n            }\r\n        }\r\n    });\r\n    return res;\r\n}\r\nexports.parseOneLine = parseOneLine;\r\n/**\r\n * 汇编！\r\n * @param asm_ 汇编代码\r\n */\r\nfunction assemble(asm_) {\r\n    // 格式化之：去掉空行；CRLF均变LF；均用单个空格分分隔；逗号后带空格，均小写。\r\n    // TODO: 是否能实现报错行号与实际情况严格对应？（此处去除了空行，实际上不对应）\r\n    var asm = asm_\r\n        .replace(/\\r\\n/g, '\\n')\r\n        .replace(/#(.*)\\n/g, '\\n')\r\n        .replace(/:\\s*\\n/g, ': ')\r\n        .split('\\n')\r\n        .filter(function (x) { return x.trim(); })\r\n        .map(function (x) { return x.trim().replace(/\\s+/g, ' ').replace(/,\\s*/, ', ').toLowerCase(); });\r\n    // 挑出代码段和数据段\r\n    var dataSegStartLine = asm.findIndex(function (v) { return v.match(/\\.data/); });\r\n    var textSegStartLine = asm.findIndex(function (v) { return v.match(/\\.text/); });\r\n    utils_1.assert(dataSegStartLine !== -1, '未找到数据段开始。');\r\n    utils_1.assert(textSegStartLine !== -1, '未找到代码段开始。');\r\n    utils_1.assert(dataSegStartLine < textSegStartLine, '数据段不能位于代码段之后。');\r\n    // 解析数据段\r\n    var dataSeg = parseDataSeg(asm.slice(dataSegStartLine, textSegStartLine));\r\n    // 解析代码段\r\n    var textSeg = parseTextSeg(asm.slice(textSegStartLine));\r\n    return {\r\n        dataSeg: dataSeg,\r\n        textSeg: textSeg,\r\n    };\r\n}\r\nexports.assemble = assemble;\r\nvar templateObject_1, templateObject_2;\r\n\n\n//# sourceURL=webpack:///./package/assembler.ts?");

/***/ }),

/***/ "./package/convert.ts":
/*!****************************!*\
  !*** ./package/convert.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys汇编器 - coe、txt文件导出\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.coeToTxt = exports.textSegToCoe = exports.dataSegToCoe = void 0;\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./package/utils.ts\");\r\n/**\r\n * 数据段转coe文件\r\n * @param padTo 补齐到多少KByte\r\n */\r\nfunction dataSegToCoe(dataSeg, padTo) {\r\n    if (padTo === void 0) { padTo = 64; }\r\n    var wordLength = utils_1.sizeof('word');\r\n    var coe = 'memory_initialization_radix = 16;\\nmemory_initialization_vector =\\n';\r\n    var lineLimit = (padTo * 1024) / wordLength;\r\n    var buf = '', lineno = 0;\r\n    dataSeg.vars.forEach(function (v) {\r\n        if (v.addr / wordLength - lineno > 0 && buf.length > 0) {\r\n            coe += buf.padStart(8, '0') + ',\\n';\r\n            buf = '';\r\n            lineno++;\r\n        }\r\n        coe += '00000000,\\n'.repeat(v.addr / wordLength - lineno);\r\n        lineno = v.addr / wordLength;\r\n        buf = '00'.repeat(((v.addr % wordLength) - buf.length / 2 + wordLength) % wordLength) + buf;\r\n        v.comps.forEach(function (comp) {\r\n            utils_1.assert(lineno < lineLimit, \"\\u53D8\\u91CF \" + v.name + \" \\u5730\\u5740\\u8D85\\u51FA\\u9650\\u5236\");\r\n            switch (comp.type) {\r\n                case 'ascii':\r\n                    comp.val.split('').forEach(function (c) {\r\n                        buf = utils_1.decToHex(c.charCodeAt(0), 8, false) + buf;\r\n                        if (buf.length == 8) {\r\n                            coe += buf + ',\\n';\r\n                            buf = '';\r\n                            lineno++;\r\n                        }\r\n                    });\r\n                    utils_1.assert(lineno < lineLimit, \"\\u53D8\\u91CF \" + v.name + \" \\u5730\\u5740\\u8D85\\u51FA\\u9650\\u5236\");\r\n                    break;\r\n                case 'space':\r\n                    buf = '00' + buf;\r\n                    break;\r\n                default:\r\n                    buf = utils_1.binToHex(utils_1.literalToBin(comp.val, utils_1.sizeof(comp.type) * 8, true), false) + buf;\r\n            }\r\n            utils_1.assert(buf.length <= 8, \"\\u53D8\\u91CF \" + v.name + \" \\u4E2D\\u5B58\\u5728\\u672A\\u5BF9\\u9F50\\u5730\\u5740\");\r\n            if (buf.length == 8) {\r\n                coe += buf + ',\\n';\r\n                buf = '';\r\n                lineno++;\r\n            }\r\n        });\r\n    });\r\n    if (buf.length > 0) {\r\n        coe += '0'.repeat(8 - buf.length) + buf + ',\\n';\r\n        lineno++;\r\n    }\r\n    coe += '00000000,\\n'.repeat(lineLimit - lineno);\r\n    return coe.slice(0, -2) + ';\\n';\r\n}\r\nexports.dataSegToCoe = dataSegToCoe;\r\n/**\r\n * 代码段转coe文件\r\n * @param padTo 补齐到多少KByte\r\n */\r\nfunction textSegToCoe(textSeg, padTo) {\r\n    if (padTo === void 0) { padTo = 64; }\r\n    var wordLength = utils_1.sizeof('word');\r\n    var coe = 'memory_initialization_radix = 16;\\nmemory_initialization_vector =\\n';\r\n    var lineLimit = (padTo * 1024) / wordLength;\r\n    var startLine = Number(textSeg.startAddr) / wordLength;\r\n    var lineno = 0;\r\n    coe += '00000000,\\n'.repeat(startLine);\r\n    textSeg.ins.forEach(function (ins) {\r\n        utils_1.assert(lineno + startLine < lineLimit, \"\\u7B2C \" + lineno + \" \\u6761\\u6307\\u4EE4 \" + ins.symbol + \" \\u5730\\u5740\\u8D85\\u51FA\\u9650\\u5236\");\r\n        var buf = '';\r\n        ins.components.forEach(function (comp) {\r\n            buf += comp.val;\r\n        });\r\n        coe += utils_1.binToHex(buf, false) + ',\\n';\r\n        lineno++;\r\n    });\r\n    coe += '00000000,\\n'.repeat(lineLimit - lineno - startLine);\r\n    return coe.slice(0, -2) + ';\\n';\r\n}\r\nexports.textSegToCoe = textSegToCoe;\r\n/**\r\n * 将两个coe文件并为可用UART串口写入的ASCII流文件\r\n */\r\nfunction coeToTxt(programCoe, dataCoe) {\r\n    var introSignal = '03020000'; // 前导握手信号\r\n    /**\r\n     * coe文件内容转hex流串\r\n     */\r\n    var toStream = function (coe) {\r\n        return coe\r\n            .replace(/\\r\\n/, '\\n')\r\n            .split('\\n')\r\n            .filter(function (v) { return v.trim(); })\r\n            .slice(2)\r\n            .map(function (x) { return x.replace(/[,;]/g, ''); })\r\n            .join('');\r\n    };\r\n    var content = \"\" + introSignal + toStream(programCoe) + toStream(dataCoe);\r\n    return content;\r\n}\r\nexports.coeToTxt = coeToTxt;\r\n\n\n//# sourceURL=webpack:///./package/convert.ts?");

/***/ }),

/***/ "./package/entry/browser.ts":
/*!**********************************!*\
  !*** ./package/entry/browser.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys汇编器 - 浏览器端编译入口\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar assembler_1 = __webpack_require__(/*! ../assembler */ \"./package/assembler.ts\");\r\nvar convert_1 = __webpack_require__(/*! ../convert */ \"./package/convert.ts\");\r\nvar lastModifiedInfo = ''; // 页面提示语\r\nfunction $(selector) {\r\n    return document.querySelector(selector);\r\n}\r\n// @ts-ignore\r\nvar editor = window.editor;\r\nvar statusBgDOM = $('.status');\r\nvar statusDOM = $('#asm-status');\r\nvar traceDOM = $('#asm-failTrace');\r\nvar resultDOM = $('#asm-result');\r\n/**\r\n * 修改提示状态\r\n */\r\nfunction setStatus(to, trace) {\r\n    var successColor = '#cf9';\r\n    var failColor = '#f99';\r\n    if (to === 'success') {\r\n        statusBgDOM.style.background = successColor;\r\n        statusDOM.innerText = '成功';\r\n        traceDOM.innerText = '';\r\n    }\r\n    if (to === 'fail') {\r\n        statusBgDOM.style.background = failColor;\r\n        statusDOM.innerText = '失败';\r\n        traceDOM.innerText = trace || '';\r\n    }\r\n}\r\n/**\r\n * 网页端触发汇编\r\n */\r\nfunction assembleBrowser() {\r\n    var asmCode = editor.getValue();\r\n    try {\r\n        var result = assembler_1.assemble(asmCode);\r\n        var binary = result.textSeg.toBinary();\r\n        resultDOM.value = binary;\r\n        setStatus('success');\r\n    }\r\n    catch (ex) {\r\n        setStatus('fail', ex);\r\n        console.error(ex);\r\n        resultDOM.value = '';\r\n    }\r\n}\r\n/**\r\n * 形成文件供下载\r\n */\r\nfunction downloadFile(content, filename) {\r\n    var linkDOM = document.createElement('a');\r\n    linkDOM.download = filename;\r\n    linkDOM.style.display = 'none';\r\n    // 字符内容转二进制大对象\r\n    var blob = new Blob([content]);\r\n    linkDOM.href = URL.createObjectURL(blob);\r\n    // 触发点击\r\n    document.body.appendChild(linkDOM);\r\n    linkDOM.click();\r\n    // 移除\r\n    document.body.removeChild(linkDOM);\r\n}\r\nwindow.addEventListener('load', function () {\r\n    // 按钮处理逻辑\r\n    $('#asm-assemble').onclick = assembleBrowser;\r\n    $('#asm-download-coe').onclick = function () {\r\n        try {\r\n            var result = assembler_1.assemble(editor.getValue());\r\n            downloadFile(convert_1.dataSegToCoe(result.dataSeg), 'dmem32.coe');\r\n            downloadFile(convert_1.textSegToCoe(result.textSeg), 'prgmip32.coe');\r\n            setStatus('success');\r\n        }\r\n        catch (ex) {\r\n            setStatus('fail', ex);\r\n            console.error(ex);\r\n        }\r\n    };\r\n    $('#asm-download-txt').onclick = function () {\r\n        try {\r\n            var result = assembler_1.assemble(editor.getValue());\r\n            var dataCoe = convert_1.dataSegToCoe(result.dataSeg);\r\n            var textCoe = convert_1.textSegToCoe(result.textSeg);\r\n            downloadFile(convert_1.coeToTxt(textCoe, dataCoe), 'serial.txt');\r\n            setStatus('success');\r\n        }\r\n        catch (ex) {\r\n            setStatus('fail', ex);\r\n            console.error(ex);\r\n        }\r\n    };\r\n    $('#asm-lastModified').innerHTML = lastModifiedInfo;\r\n});\r\n\n\n//# sourceURL=webpack:///./package/entry/browser.ts?");

/***/ }),

/***/ "./package/instruction.ts":
/*!********************************!*\
  !*** ./package/instruction.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys指令定义\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nvar __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MinisysInstructions = exports.Instruction = void 0;\r\nvar register_1 = __webpack_require__(/*! ./register */ \"./package/register.ts\");\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./package/utils.ts\");\r\nvar nop = function () { };\r\n/**\r\n * 指令类\r\n */\r\nvar Instruction = /** @class */ (function () {\r\n    function Instruction(symbol, desc, pseudo, insPattern, components) {\r\n        this._symbol = symbol;\r\n        this._desc = desc;\r\n        this._pseudo = pseudo;\r\n        this._insPattern = insPattern;\r\n        this._components = components.map(function (x) { return ({\r\n            lBit: x.lBit,\r\n            rBit: x.rBit,\r\n            desc: x.desc,\r\n            toBinary: x.toBinary,\r\n            type: x.type,\r\n            val: x.val,\r\n        }); });\r\n    }\r\n    Instruction.newInstance = function (baseOn) {\r\n        return new Instruction(baseOn.symbol, baseOn.desc, baseOn.pseudo, baseOn.insPattern, baseOn.components);\r\n    };\r\n    Object.defineProperty(Instruction.prototype, \"symbol\", {\r\n        get: function () {\r\n            return this._symbol;\r\n        },\r\n        set: function (symbol) {\r\n            this._symbol = symbol;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Instruction.prototype, \"desc\", {\r\n        get: function () {\r\n            return this._desc;\r\n        },\r\n        set: function (desc) {\r\n            this._desc = desc;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Instruction.prototype, \"pseudo\", {\r\n        get: function () {\r\n            return this._pseudo;\r\n        },\r\n        set: function (pseudo) {\r\n            this._pseudo = pseudo;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Instruction.prototype, \"insPattern\", {\r\n        get: function () {\r\n            return this._insPattern;\r\n        },\r\n        set: function (insPattern) {\r\n            this._insPattern = insPattern;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Instruction.prototype, \"components\", {\r\n        get: function () {\r\n            return this._components;\r\n        },\r\n        set: function (components) {\r\n            this._components = components;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * 设置指令组分\r\n     */\r\n    Instruction.prototype.setComponent = function (desc, val) {\r\n        var index = this._components.findIndex(function (v) { return v.desc == desc; });\r\n        utils_1.assert(index !== -1, \"\\u672A\\u77E5\\u7684\\u6307\\u4EE4\\u7EC4\\u5206: \" + desc);\r\n        this._components[index].val = val;\r\n    };\r\n    /**\r\n     * 指令转二进制\r\n     */\r\n    Instruction.prototype.toBinary = function () {\r\n        utils_1.assert(!this._components.some(function (v) { return !v.val.trim(); }), '尝试将不完整的指令转为2或16进制。');\r\n        return this._components.map(function (v) { return v.val; }).join('');\r\n    };\r\n    /**\r\n     * 指令转十六进制\r\n     */\r\n    Instruction.prototype.toHex = function (zeroX) {\r\n        if (zeroX === void 0) { zeroX = true; }\r\n        return utils_1.binToHex(this.toBinary(), zeroX);\r\n    };\r\n    return Instruction;\r\n}());\r\nexports.Instruction = Instruction;\r\n/**\r\n * Minisys指令集\r\n */\r\nexports.MinisysInstructions = (function () {\r\n    var _MinisysInstructions = [];\r\n    // 新增指令\r\n    function newInstruction(symbol, desc, pseudo, insPattern, components) {\r\n        _MinisysInstructions.push(new Instruction(symbol, desc, pseudo, insPattern, components.map(function (x) { return ({\r\n            lBit: x[0],\r\n            rBit: x[1],\r\n            desc: x[2],\r\n            toBinary: x[3],\r\n            type: x[4],\r\n            val: x[5],\r\n        }); })));\r\n    }\r\n    /**\r\n     * 获取指令正则模式\r\n     * @param params 汇编指令的参数个数\r\n     */\r\n    function paramPattern(num) {\r\n        if (num < 1) {\r\n            return /^$/;\r\n        }\r\n        else {\r\n            // prettier-ignore\r\n            return new RegExp('^' + Array(num).fill(String.raw(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"([w$-]+)\"], [\"([\\\\w$-]+)\"])))).join(',') + '$');\r\n        }\r\n    }\r\n    // =================== R型指令 ===================\r\n    newInstruction('add', '按字加法', '(rd)←(rs)+(rt)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '100000'],\r\n    ]);\r\n    newInstruction('addu', '无符号加', '(rd)←(rs)+(rt)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '100001'],\r\n    ]);\r\n    newInstruction('sub', '按字减法', '(rd)←(rs)-(rt)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '100010'],\r\n    ]);\r\n    newInstruction('subu', '无符号减', '(rd)←(rs)-(rt)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '100011'],\r\n    ]);\r\n    newInstruction('and', '按位与', '(rd)←(rs)&(rt)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '100100'],\r\n    ]);\r\n    newInstruction('mult', '按字乘法', '(HI,LO)←(rs)*(rt)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 6, 'rd+shamt', nop, 'fixed', '0000000000'],\r\n        [5, 0, 'func', nop, 'fixed', '011000'],\r\n    ]);\r\n    newInstruction('multu', '无符号乘', '(HI,LO)←(rs)*(rt)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 6, 'rd+shamt', nop, 'fixed', '0000000000'],\r\n        [5, 0, 'func', nop, 'fixed', '011001'],\r\n    ]);\r\n    newInstruction('div', '除法', '(HI)←(rs)%(rt), (LO)←(rs)/(rt)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 6, 'rd+shamt', nop, 'fixed', '0000000000'],\r\n        [5, 0, 'func', nop, 'fixed', '011010'],\r\n    ]);\r\n    newInstruction('divu', '无符号除', '(HI)←(rs)%(rt), (LO)←(rs)/(rt)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 6, 'rd+shamt', nop, 'fixed', '0000000000'],\r\n        [5, 0, 'func', nop, 'fixed', '011011'],\r\n    ]);\r\n    newInstruction('mfhi', '取HI', '(rd)←(HI)', paramPattern(1), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 16, 'rs+rt', nop, 'fixed', '0000000000'],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '010000'],\r\n    ]);\r\n    newInstruction('mflo', '取LO', '(rd)←(LO)', paramPattern(1), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 16, 'rs+rt', nop, 'fixed', '0000000000'],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '010010'],\r\n    ]);\r\n    newInstruction('mthi', '存HI', '(HI)←(rs)', paramPattern(1), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 6, 'rt+rd+shamt', nop, 'fixed', '000000000000000'],\r\n        [5, 0, 'func', nop, 'fixed', '010001'],\r\n    ]);\r\n    newInstruction('mtlo', '存LO', '(LO)←(rs)', paramPattern(1), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 6, 'rt+rd+shamt', nop, 'fixed', '000000000000000'],\r\n        [5, 0, 'func', nop, 'fixed', '010011'],\r\n    ]);\r\n    // 注意MFC0和MTC0的特殊性\r\n    newInstruction('mfc0', '取C0', '(rt)=由(rd)和sel确定的C0寄存器的值', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '010000'],\r\n        [25, 21, 'rs', nop, 'fixed', '00000'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', function () { return utils_1.literalToBin(RegExp.$3, 6); }, 'c0sel', ''],\r\n    ]);\r\n    newInstruction('mtc0', '存C0', '由(rd)和sel确定的C0寄存器的值=(rt)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '010000'],\r\n        [25, 21, 'rs', nop, 'fixed', '00100'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', function () { return utils_1.literalToBin(RegExp.$3, 6); }, 'c0sel', ''],\r\n    ]);\r\n    newInstruction('or', '按位或', '(rd)←(rs)|(rt)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '100101'],\r\n    ]);\r\n    newInstruction('xor', '按位异或', '(rd)←(rs)^(rt)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '100110'],\r\n    ]);\r\n    newInstruction('nor', '按位或非', '(rd)←~((rs)|(rt))', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '100111'],\r\n    ]);\r\n    newInstruction('slt', '有符号比较', 'if (rs<rt) rd=1 else rd=0', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '101010'],\r\n    ]);\r\n    newInstruction('sltu', '无符号比较', 'if (rs<rt) rd=1 else rd=0', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '101011'],\r\n    ]);\r\n    newInstruction('sll', '逻辑左移', '(rd)←(rt)<<shamt', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', nop, 'fixed', '00000'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', function () { return utils_1.literalToBin(RegExp.$3, 5); }, 'shamt', ''],\r\n        [5, 0, 'func', nop, 'fixed', '000000'],\r\n    ]);\r\n    newInstruction('srl', '逻辑右移', '(rd)←(rt)>>_L shamt', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', nop, 'fixed', '00000'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', function () { return utils_1.literalToBin(RegExp.$3, 5); }, 'shamt', ''],\r\n        [5, 0, 'func', nop, 'fixed', '000010'],\r\n    ]);\r\n    newInstruction('sra', '算术右移', '(rd)←(rt)>>_A shamt', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', nop, 'fixed', '00000'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', function () { return utils_1.literalToBin(RegExp.$3, 5); }, 'shamt', ''],\r\n        [5, 0, 'func', nop, 'fixed', '000011'],\r\n    ]);\r\n    newInstruction('sllv', '逻辑左移V', '(rd)←(rt)<<(rs)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '000100'],\r\n    ]);\r\n    newInstruction('srlv', '逻辑右移V', '(rd)←(rt)>>_L (rs)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '000110'],\r\n    ]);\r\n    newInstruction('srav', '算术右移V', '(rd)←(rt)>>_L (rs)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '000111'],\r\n    ]);\r\n    newInstruction('jr', '无条件跳转（寄存器）', '(PC)←(rs)', paramPattern(1), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 6, 'rt+rd+shamt', nop, 'fixed', '000000000000000'],\r\n        [5, 0, 'func', nop, 'fixed', '001000'],\r\n    ]);\r\n    newInstruction('jalr', '暂存下条后跳转（寄存器）', '(rd)=(PC)+4,(PC)←(rs)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', nop, 'fixed', '00000'],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', nop, 'fixed', '00000'],\r\n        [5, 0, 'func', nop, 'fixed', '001001'],\r\n    ]);\r\n    newInstruction('break', '断点异常', '断点异常', paramPattern(1), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 6, 'code', function () { return utils_1.literalToBin(RegExp.$1, 20); }, 'code', ''],\r\n        [5, 0, 'func', nop, 'fixed', '001101'],\r\n    ]);\r\n    newInstruction('syscall', '系统调用', '系统调用', paramPattern(1), [\r\n        [31, 26, 'op', nop, 'fixed', '000000'],\r\n        [25, 6, 'code', function () { return utils_1.literalToBin(RegExp.$1, 20); }, 'code', ''],\r\n        [5, 0, 'func', nop, 'fixed', '001100'],\r\n    ]);\r\n    newInstruction('eret', '从中断或者异常中返回', '从中断或者异常中返回', paramPattern(0), [\r\n        [31, 26, 'op', nop, 'fixed', '010000'],\r\n        [25, 6, 'rs+rt+rd+shamt', nop, 'fixed', '10000000000000000000'],\r\n        [5, 0, 'func', nop, 'fixed', '011000'],\r\n    ]);\r\n    // =================== I型指令 ===================\r\n    newInstruction('addi', '加立即数', '(rt)←(rs)+(sign-extend)immediate', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '001000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16, true); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('addiu', '无符号加立即数', '(rt)←(rs)+(sign-extend)immediate', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '001001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16, true); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('andi', '按位与立即数', '(rt)←(rs)&(zero-extend)immediate', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '001100'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('ori', '按位或立即数', '(rt)←(rs)|(zero-extend)immediate', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '001101'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('xori', '按位异或立即数', '(rt)←(rs)^(zero-extend)immediate', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '001110'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('lui', '取立即数高16位', '(rt)←immediate<<16 & 0FFFF0000H', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '001111'],\r\n        [25, 21, 'rs', nop, 'fixed', '00000'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$2, 16, true); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('lb', '取字节', '(rt)←(Sign-Extend)Memory[(rs)+(sign_extend)offset]', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', nop, 'fixed', '100000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('lbu', '取无符号字节', '(rt)←(Zero-Extend)Memory[(rs)+(sign_extend)offset]', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', nop, 'fixed', '100100'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('lh', '取半字', '(rt)←(Sign-Extend)Memory[(rs)+(sign_extend)offset]', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', nop, 'fixed', '100001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('lhu', '取无符号半字', '(rt)←(Zero-Extend)Memory[(rs)+(sign_extend)offset]', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', nop, 'fixed', '100101'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('sb', '存字节', 'Memory[(rs)+(sign_extend)offset]←(rt)7..0', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', nop, 'fixed', '101000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('sh', '存半字', 'Memory[(rs)+(sign_extend)offset]←(rt)15..0', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', nop, 'fixed', '101001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('lw', '取字', '(rt)←Memory[(rs)+(sign_extend)offset]', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', nop, 'fixed', '100011'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('sw', '存字', 'Memory[(rs)+(sign_extend)offset]←(rt)', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', nop, 'fixed', '101011'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('beq', '相等分支', 'if ((rt)=(rs)) then (PC)←(PC)+4+((Sign-Extend)offset<<2)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000100'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$3, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bne', '不等分支', 'if ((rt)≠(rs)) then (PC)←(PC)+4+((Sign-Extend)offset<<2)', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '000101'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$3, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bgez', '大于等于0分支', 'if ((rs)≥0) then (PC)←(PC)+4+((Sign-Extend)offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', nop, 'fixed', '00001'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bgtz', '大于0分支', 'if ((rs)＞0) then (PC)←(PC)+4+((Sign-Extend)offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000111'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', nop, 'fixed', '00000'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('blez', '小于等于0分支', 'if ((rs)≤0) then (PC)←(PC)+4+((Sign-Extend)offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000110'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', nop, 'fixed', '00000'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bltz', '小于0分支', 'if ((rs)＜0) then (PC)←(PC)+4+((Sign-Extend) offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000111'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', nop, 'fixed', '00000'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bgezal', '大于等于0分支（Link）', 'if ((rs)≥0) then ($31)←(PC)+4,(PC)←(PC)+4+((Sign-Extend) offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', nop, 'fixed', '10001'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bltzal', '小于0分支（Link）', 'if ((rs)＜0) then ($31)←(PC)+4,(PC)←(PC)+4+((Sign-Extend) offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', nop, 'fixed', '000001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', nop, 'fixed', '10000'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('slti', '小于立即数时Set', 'if ((rs)<(Sign-Extend)immediate) then (rt)←1; else (rt)←0', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '001010'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16, true); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('sltiu', '小于立即数时Set（无符号）', 'if ((rs)<(Zero-Extend)immediate) then (rt)←1; else (rt)←0', paramPattern(3), [\r\n        [31, 26, 'op', nop, 'fixed', '001011'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16); }, 'immed', ''],\r\n    ]);\r\n    // =================== J型指令 ===================\r\n    newInstruction('j', '无条件跳转', '(PC)←((Zero-Extend)address<<2)', paramPattern(1), [\r\n        [31, 26, 'op', nop, 'fixed', '000010'],\r\n        [25, 0, 'target', function () { return utils_1.labelToBin(RegExp.$1, 28, false).slice(-28, -2); }, 'addr', ''],\r\n    ]);\r\n    newInstruction('jal', '暂存下条后跳转（立即数）', '($31)←(PC)+4; (PC)←((Zero-Extend)address<<2),', paramPattern(1), [\r\n        [31, 26, 'op', nop, 'fixed', '000011'],\r\n        [25, 0, 'target', function () { return utils_1.labelToBin(RegExp.$1, 28, false).slice(-28, -2); }, 'addr', ''],\r\n    ]);\r\n    // =================== NOP指令 ===================\r\n    newInstruction('nop', '空转指令', 'do nothing', paramPattern(0), [[31, 0, 'NOP', nop, 'fixed', '0'.repeat(32)]]);\r\n    return _MinisysInstructions;\r\n})();\r\nvar templateObject_1;\r\n\n\n//# sourceURL=webpack:///./package/instruction.ts?");

/***/ }),

/***/ "./package/register.ts":
/*!*****************************!*\
  !*** ./package/register.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys寄存器定义\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.regToBin = void 0;\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./package/utils.ts\");\r\n// prettier-ignore\r\nvar registerNames = [\r\n    'zero', 'at',\r\n    'v0', 'v1',\r\n    'a0', 'a1', 'a2', 'a3',\r\n    't0', 't1', 't2', 't3', 't4', 't5', 't6', 't7',\r\n    's0', 's1', 's2', 's3', 's4', 's5', 's6', 's7',\r\n    'k0', 'k1',\r\n    'gp', 'sp', 'fp',\r\n    'ra',\r\n];\r\n/**\r\n * 返回寄存器对应的五位二进制号\r\n * @example $1 1 sp $sp\r\n * @warn 请勿在本函数内覆盖RegExp.$x // FIXME\r\n */\r\nfunction regToBin(reg) {\r\n    reg = reg.replace('$', '').trim();\r\n    var regNumber;\r\n    if (reg.split('').every(function (x) { return '0123456789'.includes(x); })) {\r\n        regNumber = Number(reg);\r\n    }\r\n    else {\r\n        regNumber = registerNames.indexOf(reg);\r\n    }\r\n    utils_1.assert(regNumber >= 0 && regNumber <= 31, \"\\u65E0\\u6548\\u7684\\u5BC4\\u5B58\\u5668: \" + reg);\r\n    return utils_1.decToBin(regNumber, 5);\r\n}\r\nexports.regToBin = regToBin;\r\n\n\n//# sourceURL=webpack:///./package/register.ts?");

/***/ }),

/***/ "./package/utils.ts":
/*!**************************!*\
  !*** ./package/utils.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Utilities\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getOffsetAddr = exports.getOffset = exports.sizeof = exports.serialString = exports.hexToBin = exports.hexToDec = exports.decToHex = exports.binToHex = exports.decToBin = exports.literalToBin = exports.varToAddrBin = exports.labelToBin = exports.assert = void 0;\r\nvar assembler_1 = __webpack_require__(/*! ./assembler */ \"./package/assembler.ts\");\r\n/**\r\n * Ensure `ensure`, else throw `Error(hint)`.\r\n */\r\nfunction assert(ensure, hint) {\r\n    if (!ensure) {\r\n        throw new Error(hint);\r\n    }\r\n}\r\nexports.assert = assert;\r\n/**\r\n * 将label或字面量转换为二进制\r\n * @param label label名称或字面量数字\r\n * @param len 转换后的长度\r\n * @param isOffset 转换而成的是否为相对当前地址的偏移量\r\n * @param signExt 转换后位数不足时是否进行符号扩展，默认采用零扩展\r\n */\r\nfunction labelToBin(label, len, isOffset, signExt) {\r\n    if (signExt === void 0) { signExt = false; }\r\n    try {\r\n        return literalToBin(label, len, signExt).slice(-len);\r\n    }\r\n    catch (e) {\r\n        return literalToBin((assembler_1.getLabelAddr(label) - (isOffset ? assembler_1.getPC() : 0)).toString(), len, isOffset).slice(-len);\r\n    }\r\n}\r\nexports.labelToBin = labelToBin;\r\n/**\r\n * 将变量名或字面量转换为二进制\r\n * @param name 变量名称或字面量数字\r\n * @param len 转换后的长度\r\n * @param signExt 转换后位数不足时是否进行符号扩展，默认采用零扩展\r\n */\r\nfunction varToAddrBin(name, len, signExt) {\r\n    if (signExt === void 0) { signExt = false; }\r\n    try {\r\n        return literalToBin(name, len, signExt).slice(-len);\r\n    }\r\n    catch (_) {\r\n        return literalToBin(assembler_1.getVarAddr(name).toString(), len).slice(-len);\r\n    }\r\n}\r\nexports.varToAddrBin = varToAddrBin;\r\n/**\r\n * 把字面量数字转换为二进制\r\n * @param literal 要转换的字面量数字\r\n * @param len 转换后的最少位数\r\n * @param signExt 转换后位数不足时是否进行符号扩展，默认采用零扩展\r\n * @example 10\r\n * @example 0xabcd\r\n */\r\nfunction literalToBin(literal, len, signExt) {\r\n    if (signExt === void 0) { signExt = false; }\r\n    assert(!isNaN(Number(literal)), \"\\u9519\\u8BEF\\u7684\\u53C2\\u6570\\uFF1A\" + literal);\r\n    if (literal.startsWith('0x')) {\r\n        var num = hexToBin(literal);\r\n        return num.padStart(len, signExt && parseInt(literal, 16) < 0 ? '1' : '0');\r\n    }\r\n    else {\r\n        return decToBin(parseInt(literal), len, signExt);\r\n    }\r\n}\r\nexports.literalToBin = literalToBin;\r\n/**\r\n * 将十进制数转为二进制，用pad补齐到len位，支持负数\r\n */\r\nfunction decToBin(dec, len, signExt) {\r\n    if (signExt === void 0) { signExt = false; }\r\n    var num = '';\r\n    if (dec < 0) {\r\n        // 算补码\r\n        num = (-dec - 1)\r\n            .toString(2)\r\n            .split('')\r\n            .map(function (v) { return String.fromCharCode(v.charCodeAt(0) ^ 1); })\r\n            .join('');\r\n    }\r\n    else {\r\n        num = dec.toString(2);\r\n    }\r\n    return num.padStart(len, signExt && dec < 0 ? '1' : '0');\r\n}\r\nexports.decToBin = decToBin;\r\n/**\r\n * 将4n位二进制转为n位十六进制\r\n */\r\nfunction binToHex(bin, zeroX) {\r\n    if (zeroX === void 0) { zeroX = true; }\r\n    if (bin.length % 4 !== 0) {\r\n        throw new Error('二进制位数不为4的倍数。');\r\n    }\r\n    return (['', '0x'][Number(zeroX)] +\r\n        bin\r\n            .match(/\\d{4}/g) // [1000, 1000]\r\n            .map(function (v) { return '0123456789abcdef'.charAt(parseInt(v, 2)); })\r\n            .join(''));\r\n}\r\nexports.binToHex = binToHex;\r\n/**\r\n * 将十进制数转为十六进制，十进制数会先被转换为4n位二进制\r\n */\r\nfunction decToHex(dec, len, zeroX) {\r\n    if (zeroX === void 0) { zeroX = true; }\r\n    return binToHex(decToBin(dec, len, false), zeroX);\r\n}\r\nexports.decToHex = decToHex;\r\n/**\r\n * 十六进制转十进制\r\n */\r\nfunction hexToDec(hex) {\r\n    return parseInt(hex, 16);\r\n}\r\nexports.hexToDec = hexToDec;\r\n/**\r\n * 将十六进制每位转换为4位二进制，参数带不带0x头都可以\r\n */\r\nfunction hexToBin(hex) {\r\n    if (hex.startsWith('0x')) {\r\n        hex = hex.substr(2);\r\n    }\r\n    var table = Array(16)\r\n        .fill('')\r\n        .map(function (_, i) { return decToBin(i, 4, false); });\r\n    var res = '';\r\n    hex.split('').forEach(function (v) {\r\n        res += table['0123456789abcdef'.indexOf(v)];\r\n    });\r\n    return res;\r\n}\r\nexports.hexToBin = hexToBin;\r\n/**\r\n * 去除一串字符串中的全部空格\r\n */\r\nfunction serialString(bin) {\r\n    return bin.replace(/\\s+/g, '');\r\n}\r\nexports.serialString = serialString;\r\n/**\r\n * 获取变量组分或指令占用的字节数\r\n */\r\nfunction sizeof(type) {\r\n    var size = {\r\n        byte: 1,\r\n        half: 2,\r\n        word: 4,\r\n        space: 1,\r\n        ascii: 1,\r\n        ins: 4,\r\n    }[type] || -1;\r\n    assert(size !== -1, \"\\u9519\\u8BEF\\u7684\\u53D8\\u91CF\\u7C7B\\u578B\\uFF1A\" + type);\r\n    return size;\r\n}\r\nexports.sizeof = sizeof;\r\n/**\r\n * 算地址偏移量\r\n */\r\nfunction getOffset(holder) {\r\n    return ((holder.byte || 0) * sizeof('byte') +\r\n        (holder.half || 0) * sizeof('half') +\r\n        (holder.word || 0) * sizeof('word') +\r\n        (holder.ascii || 0) * sizeof('ascii') +\r\n        (holder.space || 0) +\r\n        (holder.ins || 0) * sizeof('word'));\r\n}\r\nexports.getOffset = getOffset;\r\n/**\r\n * 算偏移后的地址\r\n * @param baseAddr 基地址，十六进制或十进制\r\n */\r\nfunction getOffsetAddr(baseAddr, offsetBit) {\r\n    var base = baseAddr.startsWith('0x') ? hexToDec(baseAddr) : Number(baseAddr);\r\n    return base + offsetBit;\r\n}\r\nexports.getOffsetAddr = getOffsetAddr;\r\n\n\n//# sourceURL=webpack:///./package/utils.ts?");

/***/ })

/******/ });