/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./package/entry/browser.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/unraw/dist/errors.js":
/*!*******************************************!*\
  !*** ./node_modules/unraw/dist/errors.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * @file **unraw - errors.ts** | Error messages used by `unraw`.\r\n * @author Ian Sanders\r\n * @copyright 2019 Ian Sanders\r\n * @license MIT\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// NOTE: don't construct errors here or they'll have the wrong stack trace.\r\n// NOTE: don't make custom error class; the JS engines use `SyntaxError`\r\n/**\r\n * Keys for possible error messages used by `unraw`.\r\n * Note: These do _not_ map to actual error object types. All errors thrown\r\n * are `SyntaxError`.\r\n */\r\n// Don't use const enum or JS users won't be able to access the enum values\r\nvar ErrorType;\r\n(function (ErrorType) {\r\n    /**\r\n     * Thrown when a badly formed Unicode escape sequence is found. Possible\r\n     * reasons include the code being too short (`\"\\u25\"`) or having invalid\r\n     * characters (`\"\\u2$A5\"`).\r\n     */\r\n    ErrorType[\"MalformedUnicode\"] = \"MALFORMED_UNICODE\";\r\n    /**\r\n     * Thrown when a badly formed hexadecimal escape sequence is found. Possible\r\n     * reasons include the code being too short (`\"\\x2\"`) or having invalid\r\n     * characters (`\"\\x2$\"`).\r\n     */\r\n    ErrorType[\"MalformedHexadecimal\"] = \"MALFORMED_HEXADECIMAL\";\r\n    /**\r\n     * Thrown when a Unicode code point escape sequence has too high of a code\r\n     * point. The maximum code point allowed is `\\u{10FFFF}`, so `\\u{110000}` and\r\n     * higher will throw this error.\r\n     */\r\n    ErrorType[\"CodePointLimit\"] = \"CODE_POINT_LIMIT\";\r\n    /**\r\n     * Thrown when an octal escape sequences is encountered and `allowOctals` is\r\n     * `false`. For example, `unraw(\"\\234\", false)`.\r\n     */\r\n    ErrorType[\"OctalDeprecation\"] = \"OCTAL_DEPRECATION\";\r\n    /**\r\n     * Thrown only when a single backslash is found at the end of a string. For\r\n     * example, `\"\\\\\"` or `\"test\\\\x24\\\\\"`.\r\n     */\r\n    ErrorType[\"EndOfString\"] = \"END_OF_STRING\";\r\n})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));\r\n/** Map of error message names to the full text of the message. */\r\nexports.errorMessages = new Map([\r\n    [ErrorType.MalformedUnicode, \"malformed Unicode character escape sequence\"],\r\n    [\r\n        ErrorType.MalformedHexadecimal,\r\n        \"malformed hexadecimal character escape sequence\"\r\n    ],\r\n    [\r\n        ErrorType.CodePointLimit,\r\n        \"Unicode codepoint must not be greater than 0x10FFFF in escape sequence\"\r\n    ],\r\n    [\r\n        ErrorType.OctalDeprecation,\r\n        '\"0\"-prefixed octal literals and octal escape sequences are deprecated; ' +\r\n            'for octal literals use the \"0o\" prefix instead'\r\n    ],\r\n    [ErrorType.EndOfString, \"malformed escape sequence at end of string\"]\r\n]);\r\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack:///./node_modules/unraw/dist/errors.js?");

/***/ }),

/***/ "./node_modules/unraw/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/unraw/dist/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * @file **unraw** | Convert raw escape sequences to their respective characters\r\n * (undo `String.raw`).\r\n * @author Ian Sanders\r\n * @copyright 2019 Ian Sanders\r\n * @license MIT\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/unraw/dist/errors.js\");\r\nexports.ErrorType = errors_1.ErrorType;\r\nexports.errorMessages = errors_1.errorMessages;\r\n/**\r\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\r\n * will not allow any other characters, including (for example) \"+\", \"-\", and\r\n * \".\".\r\n * @param hex A string containing a hexadecimal number.\r\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\r\n * number.\r\n */\r\nfunction parseHexToInt(hex) {\r\n    const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\r\n    return isOnlyHexChars ? parseInt(hex, 16) : NaN;\r\n}\r\n/**\r\n * Check the validity and length of a hexadecimal code and optionally enforces\r\n * a specific number of hex digits.\r\n * @param hex The string to validate and parse.\r\n * @param errorName The name of the error message to throw a `SyntaxError` with\r\n * if `hex` is invalid. This is used to index `errorMessages`.\r\n * @param enforcedLength If provided, will throw an error if `hex` is not\r\n * exactly this many characters.\r\n * @returns The parsed hex number as a normal number.\r\n * @throws {SyntaxError} If the code is not valid.\r\n */\r\nfunction validateAndParseHex(hex, errorName, enforcedLength) {\r\n    const parsedHex = parseHexToInt(hex);\r\n    if (Number.isNaN(parsedHex) ||\r\n        (enforcedLength !== undefined && enforcedLength !== hex.length)) {\r\n        throw new SyntaxError(errors_1.errorMessages.get(errorName));\r\n    }\r\n    return parsedHex;\r\n}\r\n/**\r\n * Parse a two-digit hexadecimal character escape code.\r\n * @param code The two-digit hexadecimal number that represents the character to\r\n * output.\r\n * @returns The single character represented by the code.\r\n * @throws {SyntaxError} If the code is not valid hex or is not the right\r\n * length.\r\n */\r\nfunction parseHexadecimalCode(code) {\r\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);\r\n    return String.fromCharCode(parsedCode);\r\n}\r\n/**\r\n * Parse a four-digit Unicode character escape code.\r\n * @param code The four-digit unicode number that represents the character to\r\n * output.\r\n * @param surrogateCode Optional four-digit unicode surrogate that represents\r\n * the other half of the character to output.\r\n * @returns The single character represented by the code.\r\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\r\n * length.\r\n */\r\nfunction parseUnicodeCode(code, surrogateCode) {\r\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);\r\n    if (surrogateCode !== undefined) {\r\n        const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);\r\n        return String.fromCharCode(parsedCode, parsedSurrogateCode);\r\n    }\r\n    return String.fromCharCode(parsedCode);\r\n}\r\n/**\r\n * Test if the text is surrounded by curly braces (`{}`).\r\n * @param text Text to check.\r\n * @returns `true` if the text is in the form `{*}`.\r\n */\r\nfunction isCurlyBraced(text) {\r\n    return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\r\n}\r\n/**\r\n * Parse a Unicode code point character escape code.\r\n * @param codePoint A unicode escape code point, including the surrounding curly\r\n * braces.\r\n * @returns The single character represented by the code.\r\n * @throws {SyntaxError} If the code is not valid hex or does not have the\r\n * surrounding curly braces.\r\n */\r\nfunction parseUnicodeCodePointCode(codePoint) {\r\n    if (!isCurlyBraced(codePoint)) {\r\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));\r\n    }\r\n    const withoutBraces = codePoint.slice(1, -1);\r\n    const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);\r\n    try {\r\n        return String.fromCodePoint(parsedCode);\r\n    }\r\n    catch (err) {\r\n        throw err instanceof RangeError\r\n            ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit))\r\n            : err;\r\n    }\r\n}\r\n// Have to give overload that takes boolean for when compiler doesn't know if\r\n// true or false\r\nfunction parseOctalCode(code, error = false) {\r\n    if (error) {\r\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));\r\n    }\r\n    // The original regex only allows digits so we don't need to have a strict\r\n    // octal parser like hexToInt. Length is not enforced for octals.\r\n    const parsedCode = parseInt(code, 8);\r\n    return String.fromCharCode(parsedCode);\r\n}\r\n/**\r\n * Map of unescaped letters to their corresponding special JS escape characters.\r\n * Intentionally does not include characters that map to themselves like \"\\'\".\r\n */\r\nconst singleCharacterEscapes = new Map([\r\n    [\"b\", \"\\b\"],\r\n    [\"f\", \"\\f\"],\r\n    [\"n\", \"\\n\"],\r\n    [\"r\", \"\\r\"],\r\n    [\"t\", \"\\t\"],\r\n    [\"v\", \"\\v\"],\r\n    [\"0\", \"\\0\"]\r\n]);\r\n/**\r\n * Parse a single character escape sequence and return the matching character.\r\n * If none is matched, defaults to `code`.\r\n * @param code A single character code.\r\n */\r\nfunction parseSingleCharacterCode(code) {\r\n    return singleCharacterEscapes.get(code) || code;\r\n}\r\n/**\r\n * Matches every escape sequence possible, including invalid ones.\r\n *\r\n * All capture groups (described below) are unique (only one will match), except\r\n * for 4, which can only potentially match if 3 does.\r\n *\r\n * **Capture Groups:**\r\n * 0. A single backslash\r\n * 1. Hexadecimal code\r\n * 2. Unicode code point code with surrounding curly braces\r\n * 3. Unicode escape code with surrogate\r\n * 4. Surrogate code\r\n * 5. Unicode escape code without surrogate\r\n * 6. Octal code _NOTE: includes \"0\"._\r\n * 7. A single character (will never be \\, x, u, or 0-3)\r\n */\r\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\r\n/**\r\n * Replace raw escape character strings with their escape characters.\r\n * @param raw A string where escape characters are represented as raw string\r\n * values like `\\'` rather than `'`.\r\n * @param allowOctals If `true`, will process the now-deprecated octal escape\r\n * sequences (ie, `\\111`).\r\n * @returns The processed string, with escape characters replaced by their\r\n * respective actual Unicode characters.\r\n */\r\nfunction unraw(raw, allowOctals = false) {\r\n    return raw.replace(escapeMatch, function (_, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {\r\n        // Compare groups to undefined because empty strings mean different errors\r\n        // Otherwise, `\\u` would fail the same as `\\` which is wrong.\r\n        if (backslash !== undefined) {\r\n            return \"\\\\\";\r\n        }\r\n        if (hex !== undefined) {\r\n            return parseHexadecimalCode(hex);\r\n        }\r\n        if (codePoint !== undefined) {\r\n            return parseUnicodeCodePointCode(codePoint);\r\n        }\r\n        if (unicodeWithSurrogate !== undefined) {\r\n            return parseUnicodeCode(unicodeWithSurrogate, surrogate);\r\n        }\r\n        if (unicode !== undefined) {\r\n            return parseUnicodeCode(unicode);\r\n        }\r\n        if (octal === \"0\") {\r\n            return \"\\0\";\r\n        }\r\n        if (octal !== undefined) {\r\n            return parseOctalCode(octal, !allowOctals);\r\n        }\r\n        if (singleCharacter !== undefined) {\r\n            return parseSingleCharacterCode(singleCharacter);\r\n        }\r\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));\r\n    });\r\n}\r\nexports.unraw = unraw;\r\nexports.default = unraw;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/unraw/dist/index.js?");

/***/ }),

/***/ "./package/assembler.ts":
/*!******************************!*\
  !*** ./package/assembler.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys汇编器 - 汇编代码解析\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nvar __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.assemble = exports.parseOneLine = exports.getPC = exports.getLabelAddr = exports.getVarAddr = exports.TextSeg = exports.DataSeg = exports.userAddrOffset = void 0;\r\nvar unraw_1 = __importDefault(__webpack_require__(/*! unraw */ \"./node_modules/unraw/dist/index.js\"));\r\nvar instruction_1 = __webpack_require__(/*! ./instruction */ \"./package/instruction.ts\");\r\nvar macro_1 = __webpack_require__(/*! ./macro */ \"./package/macro.ts\");\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./package/utils.ts\");\r\n// 仿照如下形式来添加新的变量类型\r\n// prettier-ignore\r\nvar __VarCompType = {\r\n    byte: void 0, half: void 0, word: void 0, ascii: void 0, space: void 0\r\n};\r\nvar VarCompTypeRegex = Object.keys(__VarCompType).join('|');\r\n// 拼接BIOS后用户程序的地址偏移量\r\n// TODO: 根据情况赋值此变量\r\nexports.userAddrOffset = 0;\r\n/**\r\n * 数据段\r\n */\r\nvar DataSeg = /** @class */ (function () {\r\n    function DataSeg(startAddr, vars) {\r\n        this._startAddr = startAddr;\r\n        this._vars = Array.from(vars);\r\n    }\r\n    Object.defineProperty(DataSeg.prototype, \"startAddr\", {\r\n        get: function () {\r\n            return this._startAddr;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DataSeg.prototype, \"vars\", {\r\n        get: function () {\r\n            return this._vars;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * 添加新变量\r\n     */\r\n    DataSeg.prototype.newVar = function (name, comps, addr) {\r\n        utils_1.assert(this._vars.every(function (v) { return v.name !== name; }), '重复的变量名。');\r\n        this._vars.push({\r\n            name: name,\r\n            comps: comps,\r\n            addr: addr,\r\n        });\r\n    };\r\n    /**\r\n     * 添加新变量组分\r\n     */\r\n    DataSeg.prototype.newComp = function (name, comp) {\r\n        utils_1.assert(this._vars.some(function (v) { return v.name === name; }), '找不到该变量。');\r\n        this._vars[this._vars.findIndex(function (v) { return v.name === name; })].comps.push(comp);\r\n    };\r\n    return DataSeg;\r\n}());\r\nexports.DataSeg = DataSeg;\r\n/**\r\n * 代码段\r\n */\r\nvar TextSeg = /** @class */ (function () {\r\n    function TextSeg(startAddr, ins, labels) {\r\n        this._startAddr = startAddr;\r\n        this._ins = Array.from(ins);\r\n        this._labels = Array.from(labels);\r\n    }\r\n    Object.defineProperty(TextSeg.prototype, \"startAddr\", {\r\n        get: function () {\r\n            return this._startAddr;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TextSeg.prototype, \"ins\", {\r\n        get: function () {\r\n            return this._ins;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TextSeg.prototype, \"labels\", {\r\n        get: function () {\r\n            return this._labels;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * 代码段二进制输出\r\n     */\r\n    TextSeg.prototype.toBinary = function () {\r\n        return this._ins.map(function (v) { return v.toBinary(); }).join('\\n');\r\n    };\r\n    return TextSeg;\r\n}());\r\nexports.TextSeg = TextSeg;\r\n// 分析过程辅助变量\r\nvar vars = [];\r\nvar labels = [];\r\nvar pc = 0;\r\n/**\r\n * 获取变量地址\r\n */\r\nfunction getVarAddr(name) {\r\n    var res = vars.find(function (v) { return v.name == name; });\r\n    utils_1.assert(res, \"\\u672A\\u77E5\\u7684\\u53D8\\u91CF\\uFF1A\" + name);\r\n    return res.addr;\r\n}\r\nexports.getVarAddr = getVarAddr;\r\n/**\r\n * 获取标签地址\r\n */\r\nfunction getLabelAddr(label) {\r\n    var res = labels.find(function (v) { return v.name == label; });\r\n    utils_1.assert(res, \"\\u672A\\u77E5\\u7684\\u6807\\u7B7E\\uFF1A\" + label);\r\n    return res.addr;\r\n}\r\nexports.getLabelAddr = getLabelAddr;\r\n/**\r\n * 获取PC地址\r\n */\r\nfunction getPC() {\r\n    return pc;\r\n}\r\nexports.getPC = getPC;\r\n/**\r\n * 解析数据段\r\n * @param asm 从.data开始，到.text的前一行\r\n */\r\nfunction parseDataSeg(asm) {\r\n    // 解析初始化值\r\n    var parseInitValue = function (type, init) {\r\n        utils_1.assert(!(type !== 'ascii' && init.includes('\"')), '字符串型数据只能使用.ascii类型');\r\n        init = init.trim();\r\n        utils_1.assert(init[0] !== ',' && init[init.length - 1] !== ',', '数据初始化值头或尾有非法逗号');\r\n        if (type !== 'ascii') {\r\n            return init.split(/\\s*,/).map(function (v) { return v.trim(); });\r\n        }\r\n        else {\r\n            var inQuote = false, nextEscape = false, res = [], buf = '', prev = '';\r\n            for (var i_1 = 0; i_1 < init.length; i_1++) {\r\n                var ch = init.charAt(i_1);\r\n                if (!inQuote && !ch.trim())\r\n                    continue;\r\n                if (ch == '\"') {\r\n                    if (nextEscape) {\r\n                        utils_1.assert(inQuote, '有非法字符出现在引号以外');\r\n                        buf += '\"';\r\n                        nextEscape = false;\r\n                    }\r\n                    else {\r\n                        inQuote = !inQuote;\r\n                    }\r\n                }\r\n                else if (ch == '\\\\') {\r\n                    utils_1.assert(inQuote, '有非法字符出现在引号以外');\r\n                    if (nextEscape) {\r\n                        buf += '\\\\';\r\n                        nextEscape = false;\r\n                    }\r\n                    else {\r\n                        nextEscape = true;\r\n                    }\r\n                }\r\n                else if (ch == ',') {\r\n                    if (inQuote) {\r\n                        buf += ','; // 引号内逗号可不escape\r\n                        nextEscape = false;\r\n                    }\r\n                    else {\r\n                        utils_1.assert(prev !== ',', '数据初始化值存在连续的逗号分隔');\r\n                        res.push(buf);\r\n                        buf = '';\r\n                    }\r\n                }\r\n                else {\r\n                    utils_1.assert(inQuote, '有非法字符出现在引号以外');\r\n                    if (nextEscape) {\r\n                        buf += unraw_1.default('\\\\' + ch);\r\n                    }\r\n                    else {\r\n                        buf += ch;\r\n                    }\r\n                    nextEscape = false;\r\n                }\r\n                prev = ch;\r\n            }\r\n            res.push(buf);\r\n            return res;\r\n        }\r\n    };\r\n    // 检查起始地址\r\n    var startAddr = asm[0].split(/\\s+/)[1] || '0';\r\n    utils_1.assert(asm[0].split(/\\s+/).length <= 2, '数据段首声明非法');\r\n    // 变量声明开始正则\r\n    var VarStartPattern = new RegExp(String.raw(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"(.+):s+.(\", \")s+(.+)\"], [\"(.+):\\\\s+\\\\.(\", \")\\\\s+(.+)\"])), VarCompTypeRegex));\r\n    // 变量声明继续正则\r\n    var VarContdPattern = new RegExp(String.raw(templateObject_2 || (templateObject_2 = __makeTemplateObject([\".(\", \")s+(.+)\"], [\"\\\\.(\", \")\\\\s+(.+)\"])), VarCompTypeRegex));\r\n    var comps = [], name;\r\n    var i = 1;\r\n    var addr = Number(startAddr), nextAddr = addr;\r\n    vars = [];\r\n    var _loop_1 = function () {\r\n        if (VarStartPattern.test(asm[i])) {\r\n            // 一个新变量开始\r\n            if (name !== void 0) {\r\n                vars.push({\r\n                    name: name,\r\n                    comps: comps,\r\n                    addr: addr,\r\n                });\r\n                comps = [];\r\n                name = void 0;\r\n                addr = nextAddr;\r\n            }\r\n            name = RegExp.$1;\r\n            var type_1 = RegExp.$2;\r\n            var size_1 = utils_1.sizeof(type_1);\r\n            // 边界对齐\r\n            if (addr % size_1 > 0) {\r\n                nextAddr = addr = addr + size_1 - (addr % size_1);\r\n            }\r\n            // 推入组分记录\r\n            parseInitValue(type_1, RegExp.$3).forEach(function (val) {\r\n                comps.push({\r\n                    type: type_1,\r\n                    val: val,\r\n                });\r\n                nextAddr += size_1 * (type_1 === 'ascii' ? val.length : 1);\r\n            });\r\n        }\r\n        else if (VarContdPattern.test(asm[i])) {\r\n            // 变量组分继续\r\n            var type_2 = RegExp.$1;\r\n            var size_2 = utils_1.sizeof(type_2);\r\n            // 边界对齐，自动补.space\r\n            while (nextAddr % size_2 > 0) {\r\n                comps.push({\r\n                    type: 'space',\r\n                    val: '00',\r\n                });\r\n                nextAddr++;\r\n            }\r\n            // 推入组分记录\r\n            parseInitValue(type_2, RegExp.$2).forEach(function (val) {\r\n                comps.push({\r\n                    type: type_2,\r\n                    val: val,\r\n                });\r\n                nextAddr += size_2 * (type_2 === 'ascii' ? val.length : 1);\r\n            });\r\n        }\r\n        else {\r\n            // 报错\r\n            utils_1.assert(false, \"\\u672A\\u77E5\\u7684\\u53D8\\u91CF\\u5B9A\\u4E49\\u5F62\\u5F0F\\uFF0C\\u5728\\u6570\\u636E\\u6BB5\\u7B2C \" + (i + 1) + \" \\u884C\");\r\n        }\r\n        // 末尾处理\r\n        if (i === asm.length - 1) {\r\n            vars.push({\r\n                name: name,\r\n                comps: comps,\r\n                addr: addr,\r\n            });\r\n        }\r\n        i++;\r\n    };\r\n    // 开始扫描\r\n    while (i < asm.length) {\r\n        _loop_1();\r\n    }\r\n    return new DataSeg(startAddr, vars);\r\n}\r\n/**\r\n * 展开代码段宏指令\r\n */\r\nfunction expandMacros(asm_, lineno_) {\r\n    var asm = Array.from(asm_);\r\n    var ruleIdx = -1;\r\n    var macros = Object.keys(macro_1.expansionRules);\r\n    var bias = 0;\r\n    asm_.forEach(function (v, i) {\r\n        var LabelPattern = /^(\\w+:)\\s*([\\w\\s$]+)$/;\r\n        var labelPreserve = '';\r\n        if (v.match(LabelPattern)) {\r\n            labelPreserve = RegExp.$1;\r\n            v = RegExp.$2.trim();\r\n        }\r\n        if ((ruleIdx = macros.findIndex(function (x) { return v.match(macro_1.expansionRules[x].pattern); })) !== -1) {\r\n            var replacer = macro_1.expansionRules[macros[ruleIdx]].replacer();\r\n            replacer[0] = labelPreserve + ' ' + replacer[0];\r\n            asm.splice.apply(asm, __spreadArrays([i + bias, 1], replacer));\r\n            lineno_.splice.apply(lineno_, __spreadArrays([i + bias, 1], new Array(replacer.length).fill(lineno_[i + bias])));\r\n            bias += replacer.length - 1;\r\n        }\r\n    });\r\n    return asm;\r\n}\r\n/**\r\n * 解析代码段\r\n * @param asm .text起，到代码段结束\r\n */\r\nfunction parseTextSeg(asm_, lineno) {\r\n    // 先展开宏指令\r\n    var asm = expandMacros(asm_, lineno);\r\n    // 确定数据段起始地址\r\n    var startAddr = asm[0].split(/\\s+/)[1] || '0';\r\n    utils_1.assert(asm[0].split(/\\s+/).length <= 2, '代码段首声明非法。');\r\n    // 起始地址校正到4字节对齐（32位）\r\n    var sizeofWord = utils_1.sizeof('word');\r\n    var startAddrNumber = Number(startAddr);\r\n    startAddr = String(((sizeofWord - (startAddrNumber % sizeofWord)) % sizeofWord) + startAddrNumber);\r\n    // pc指针\r\n    pc = utils_1.getOffsetAddr(startAddr, 0);\r\n    labels = [];\r\n    // 去除label后指令实际行号\r\n    var insLineno = 1;\r\n    // 先提取掉所有的label\r\n    asm = asm.map(function (v, i) {\r\n        if (i === 0)\r\n            return v;\r\n        if (/(\\w+):\\s*(.*)/.test(v)) {\r\n            utils_1.assert(labels.every(function (label) { return label.name !== RegExp.$1; }), \"\\u5B58\\u5728\\u91CD\\u590D\\u7684label\\uFF1A\" + RegExp.$1 + \"\\uFF0C\\u5728\\u4EE3\\u7801\\u7B2C\" + lineno[i] + \"\\u884C\\u3002\");\r\n            labels.push({ name: RegExp.$1, lineno: insLineno, addr: utils_1.getOffsetAddr(startAddr, utils_1.getOffset({ ins: insLineno - 1 })) });\r\n            if (RegExp.$2.trim())\r\n                insLineno++;\r\n            return RegExp.$2;\r\n        }\r\n        insLineno++;\r\n        return v;\r\n    });\r\n    lineno = lineno.filter(function (x, i) { return asm[i].trim(); });\r\n    asm = asm.filter(function (x) { return x.trim(); });\r\n    var ins = [];\r\n    asm.forEach(function (v, i) {\r\n        i !== 0 && ins.push(parseOneLine(v, lineno[i]));\r\n    });\r\n    return new TextSeg(startAddr, ins, labels);\r\n}\r\n/**\r\n * 解析单行汇编到Instruction对象\r\n */\r\nfunction parseOneLine(asm, lineno) {\r\n    // 处理助记符\r\n    utils_1.assert(/^\\s*(\\w+)\\s*(.*)/.test(asm), \"\\u6CA1\\u6709\\u627E\\u5230\\u6307\\u4EE4\\u52A9\\u8BB0\\u7B26\\uFF0C\\u5728\\u4EE3\\u7801\\u7B2C \" + lineno + \" \\u884C\\u3002\");\r\n    var symbol = RegExp.$1;\r\n    // 检验助记符合法性\r\n    var instructionIndex = instruction_1.MinisysInstructions.findIndex(function (x) { return x.symbol == symbol; });\r\n    utils_1.assert(instructionIndex !== -1, \"\\u65E0\\u6548\\u7684\\u6307\\u4EE4\\u52A9\\u8BB0\\u7B26\\u6216\\u9519\\u8BEF\\u7684\\u6307\\u4EE4\\u7528\\u6CD5\\uFF1A\" + symbol + \"\\uFF0C\\u5728\\u4EE3\\u7801\\u7B2C \" + lineno + \" \\u884C\\u3002\");\r\n    // 单行汇编去空格\r\n    asm = utils_1.serialString(RegExp.$2);\r\n    // pc移进\r\n    pc += utils_1.sizeof('ins');\r\n    // 开始组装Instruction对象\r\n    var res = instruction_1.Instruction.newInstance(instruction_1.MinisysInstructions[instructionIndex]);\r\n    utils_1.assert(res.insPattern.test(asm), \"\\u4EE3\\u7801\\u6BB5\\u7B2C \" + lineno + \" \\u884C\\u6307\\u4EE4\\u53C2\\u6570\\u4E0D\\u5339\\u914D\\uFF1A\" + asm);\r\n    res.components.forEach(function (component) {\r\n        if (!component.val.trim() /* 代表是需要填充的变量，而不是指令二进制中的定值 */) {\r\n            try {\r\n                res.setComponent(component.desc, component.toBinary());\r\n            }\r\n            catch (err) {\r\n                err.message += \"\\uFF0C\\u5728\\u4EE3\\u7801\\u7B2C \" + lineno + \" \\u884C\";\r\n                throw err;\r\n            }\r\n        }\r\n    });\r\n    return res;\r\n}\r\nexports.parseOneLine = parseOneLine;\r\n/**\r\n * 汇编！\r\n * @param asm_ 汇编代码\r\n */\r\nfunction assemble(asm_) {\r\n    // 格式化之：去掉空行；CRLF均变LF；均用单个空格分分隔；逗号后带空格，均小写。\r\n    var asm__ = (asm_ + '\\n')\r\n        .replace(/\\r\\n/g, '\\n')\r\n        .replace(/#(.*)\\n/g, '\\n')\r\n        .split('\\n');\r\n    var lineno = Array.from(new Array(asm__.length), function (x, i) { return i + 1; })\r\n        .filter(function (x) { return asm__[x - 1].trim(); });\r\n    var asm = asm__\r\n        .filter(function (x) { return x.trim(); })\r\n        .map(function (x) { return x.trim().replace(/\\s+/g, ' ').replace(/,\\s*/, ', ').toLowerCase(); });\r\n    // 挑出代码段和数据段\r\n    var dataSegStartLine = asm.findIndex(function (v) { return v.match(/\\.data/); });\r\n    var textSegStartLine = asm.findIndex(function (v) { return v.match(/\\.text/); });\r\n    utils_1.assert(dataSegStartLine !== -1, '未找到数据段开始。');\r\n    utils_1.assert(textSegStartLine !== -1, '未找到代码段开始。');\r\n    utils_1.assert(dataSegStartLine < textSegStartLine, '数据段不能位于代码段之后。');\r\n    // 解析数据段\r\n    var dataSeg = parseDataSeg(asm.slice(dataSegStartLine, textSegStartLine));\r\n    // 解析代码段\r\n    var textSeg = parseTextSeg(asm.slice(textSegStartLine), lineno.slice(textSegStartLine));\r\n    return {\r\n        dataSeg: dataSeg,\r\n        textSeg: textSeg,\r\n    };\r\n}\r\nexports.assemble = assemble;\r\nvar templateObject_1, templateObject_2;\r\n\n\n//# sourceURL=webpack:///./package/assembler.ts?");

/***/ }),

/***/ "./package/convert.ts":
/*!****************************!*\
  !*** ./package/convert.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys汇编器 - coe、txt文件导出\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.coeToTxt = exports.textSegToCoe = exports.dataSegToCoe = void 0;\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./package/utils.ts\");\r\n/**\r\n * 数据段转coe文件\r\n * @param padTo 补齐到多少KByte\r\n */\r\nfunction dataSegToCoe(dataSeg, padTo) {\r\n    if (padTo === void 0) { padTo = 64; }\r\n    var wordLength = utils_1.sizeof('word');\r\n    var coe = 'memory_initialization_radix = 16;\\nmemory_initialization_vector =\\n';\r\n    var lineLimit = (padTo * 1024) / wordLength;\r\n    var buf = '', lineno = 0;\r\n    dataSeg.vars.forEach(function (v) {\r\n        if (v.addr / wordLength - lineno > 0 && buf.length > 0) {\r\n            coe += buf.padStart(8, '0') + ',\\n';\r\n            buf = '';\r\n            lineno++;\r\n        }\r\n        coe += '00000000,\\n'.repeat(v.addr / wordLength - lineno);\r\n        lineno = v.addr / wordLength;\r\n        buf = '00'.repeat(((v.addr % wordLength) - buf.length / 2 + wordLength) % wordLength) + buf;\r\n        v.comps.forEach(function (comp) {\r\n            utils_1.assert(lineno < lineLimit, \"\\u53D8\\u91CF \" + v.name + \" \\u5730\\u5740\\u8D85\\u51FA\\u9650\\u5236\");\r\n            switch (comp.type) {\r\n                case 'ascii':\r\n                    comp.val.split('').forEach(function (c) {\r\n                        buf = utils_1.decToHex(c.charCodeAt(0), 8, false) + buf;\r\n                        if (buf.length == 8) {\r\n                            coe += buf + ',\\n';\r\n                            buf = '';\r\n                            lineno++;\r\n                        }\r\n                    });\r\n                    utils_1.assert(lineno < lineLimit, \"\\u53D8\\u91CF \" + v.name + \" \\u5730\\u5740\\u8D85\\u51FA\\u9650\\u5236\");\r\n                    break;\r\n                case 'space':\r\n                    buf = '00' + buf;\r\n                    break;\r\n                default:\r\n                    buf = utils_1.binToHex(utils_1.literalToBin(comp.val, utils_1.sizeof(comp.type) * 8, true), false) + buf;\r\n            }\r\n            utils_1.assert(buf.length <= 8, \"\\u53D8\\u91CF \" + v.name + \" \\u4E2D\\u5B58\\u5728\\u672A\\u5BF9\\u9F50\\u5730\\u5740\");\r\n            if (buf.length == 8) {\r\n                coe += buf + ',\\n';\r\n                buf = '';\r\n                lineno++;\r\n            }\r\n        });\r\n    });\r\n    if (buf.length > 0) {\r\n        coe += '0'.repeat(8 - buf.length) + buf + ',\\n';\r\n        lineno++;\r\n    }\r\n    coe += '00000000,\\n'.repeat(lineLimit - lineno);\r\n    return coe.slice(0, -2) + ';\\n';\r\n}\r\nexports.dataSegToCoe = dataSegToCoe;\r\n/**\r\n * 代码段转coe文件\r\n * @param padTo 补齐到多少KByte\r\n */\r\nfunction textSegToCoe(textSeg, padTo) {\r\n    if (padTo === void 0) { padTo = 64; }\r\n    var wordLength = utils_1.sizeof('word');\r\n    var coe = 'memory_initialization_radix = 16;\\nmemory_initialization_vector =\\n';\r\n    var lineLimit = (padTo * 1024) / wordLength;\r\n    var startLine = Number(textSeg.startAddr) / wordLength;\r\n    var lineno = 0;\r\n    coe += '00000000,\\n'.repeat(startLine);\r\n    textSeg.ins.forEach(function (ins) {\r\n        utils_1.assert(lineno + startLine < lineLimit, \"\\u7B2C \" + lineno + \" \\u6761\\u6307\\u4EE4 \" + ins.symbol + \" \\u5730\\u5740\\u8D85\\u51FA\\u9650\\u5236\");\r\n        var buf = '';\r\n        ins.components.forEach(function (comp) {\r\n            buf += comp.val;\r\n        });\r\n        coe += utils_1.binToHex(buf, false) + ',\\n';\r\n        lineno++;\r\n    });\r\n    coe += '00000000,\\n'.repeat(lineLimit - lineno - startLine);\r\n    return coe.slice(0, -2) + ';\\n';\r\n}\r\nexports.textSegToCoe = textSegToCoe;\r\n/**\r\n * 将两个coe文件并为可用UART串口写入的ASCII流文件\r\n */\r\nfunction coeToTxt(programCoe, dataCoe) {\r\n    var introSignal = '03020000'; // 前导握手信号\r\n    /**\r\n     * coe文件内容转hex流串\r\n     */\r\n    var toStream = function (coe) {\r\n        return coe\r\n            .replace(/\\r\\n/g, '\\n')\r\n            .split('\\n')\r\n            .filter(function (v) { return v.trim(); })\r\n            .slice(2)\r\n            .map(function (x) { return x.replace(/[,;]/g, ''); })\r\n            .join('');\r\n    };\r\n    var content = \"\" + introSignal + toStream(programCoe) + toStream(dataCoe);\r\n    return content;\r\n}\r\nexports.coeToTxt = coeToTxt;\r\n\n\n//# sourceURL=webpack:///./package/convert.ts?");

/***/ }),

/***/ "./package/entry/browser.ts":
/*!**********************************!*\
  !*** ./package/entry/browser.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys汇编器 - 浏览器端编译入口\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar assembler_1 = __webpack_require__(/*! ../assembler */ \"./package/assembler.ts\");\r\nvar convert_1 = __webpack_require__(/*! ../convert */ \"./package/convert.ts\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./package/utils.ts\");\r\nvar lastModifiedInfo = ''; // 页面提示语\r\nfunction $(selector) {\r\n    return document.querySelector(selector);\r\n}\r\n// @ts-ignore\r\nvar editor = window.editor;\r\nvar statusBgDOM = $('.status');\r\nvar statusDOM = $('#asm-status');\r\nvar traceDOM = $('#asm-failTrace');\r\nvar resultDOM = $('#asm-result');\r\n/**\r\n * 修改提示状态\r\n */\r\nfunction setStatus(to, trace) {\r\n    var successColor = '#cf9';\r\n    var failColor = '#f99';\r\n    if (to === 'success') {\r\n        statusBgDOM.style.background = successColor;\r\n        statusDOM.innerText = '成功';\r\n        traceDOM.innerText = '';\r\n    }\r\n    if (to === 'fail') {\r\n        statusBgDOM.style.background = failColor;\r\n        statusDOM.innerText = '失败';\r\n        traceDOM.innerText = trace || '';\r\n    }\r\n}\r\n/**\r\n * 转换汇编结果的进制\r\n * @param res 原汇编结果\r\n */\r\nfunction assembleResultSwitch(res) {\r\n    if ($('#hexSwitch').checked) {\r\n        return res.split('\\n').map(function (binaryLine) { return utils_1.binToHex(binaryLine, false); }).join('\\n');\r\n    }\r\n    else {\r\n        return res.split('\\n').map(function (binaryLine) { return utils_1.hexToBin(binaryLine); }).join('\\n');\r\n    }\r\n}\r\n/**\r\n * 网页端触发汇编\r\n */\r\nfunction assembleBrowser() {\r\n    var asmCode = editor.getValue();\r\n    try {\r\n        var result = assembler_1.assemble(asmCode);\r\n        var binary = result.textSeg.toBinary();\r\n        if ($('#hexSwitch').checked) {\r\n            resultDOM.value = assembleResultSwitch(binary);\r\n        }\r\n        else {\r\n            resultDOM.value = binary;\r\n        }\r\n        setStatus('success');\r\n    }\r\n    catch (ex) {\r\n        setStatus('fail', ex);\r\n        console.error(ex);\r\n        resultDOM.value = '';\r\n    }\r\n}\r\n/**\r\n * 形成文件供下载\r\n */\r\nfunction downloadFile(content, filename) {\r\n    var linkDOM = document.createElement('a');\r\n    linkDOM.download = filename;\r\n    linkDOM.style.display = 'none';\r\n    // 字符内容转二进制大对象\r\n    var blob = new Blob([content]);\r\n    linkDOM.href = URL.createObjectURL(blob);\r\n    // 触发点击\r\n    document.body.appendChild(linkDOM);\r\n    linkDOM.click();\r\n    // 移除\r\n    document.body.removeChild(linkDOM);\r\n}\r\nwindow.addEventListener('load', function () {\r\n    // 汇编结果进制切换处理逻辑\r\n    $('#hexSwitch').onchange = function () {\r\n        resultDOM.value = assembleResultSwitch(resultDOM.value);\r\n    };\r\n    // 按钮处理逻辑\r\n    $('#asm-assemble').onclick = assembleBrowser;\r\n    $('#asm-download-coe').onclick = function () {\r\n        try {\r\n            var result = assembler_1.assemble(editor.getValue());\r\n            downloadFile(convert_1.dataSegToCoe(result.dataSeg), 'dmem32.coe');\r\n            downloadFile(convert_1.textSegToCoe(result.textSeg), 'prgmip32.coe');\r\n            setStatus('success');\r\n        }\r\n        catch (ex) {\r\n            setStatus('fail', ex);\r\n            console.error(ex);\r\n        }\r\n    };\r\n    $('#asm-download-txt').onclick = function () {\r\n        try {\r\n            var result = assembler_1.assemble(editor.getValue());\r\n            var dataCoe = convert_1.dataSegToCoe(result.dataSeg);\r\n            var textCoe = convert_1.textSegToCoe(result.textSeg);\r\n            downloadFile(convert_1.coeToTxt(textCoe, dataCoe), 'serial.txt');\r\n            setStatus('success');\r\n        }\r\n        catch (ex) {\r\n            setStatus('fail', ex);\r\n            console.error(ex);\r\n        }\r\n    };\r\n    $('#asm-lastModified').innerHTML = lastModifiedInfo;\r\n});\r\n\n\n//# sourceURL=webpack:///./package/entry/browser.ts?");

/***/ }),

/***/ "./package/instruction.ts":
/*!********************************!*\
  !*** ./package/instruction.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys指令定义\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nvar __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MinisysInstructions = exports.Instruction = void 0;\r\nvar register_1 = __webpack_require__(/*! ./register */ \"./package/register.ts\");\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./package/utils.ts\");\r\nvar noop = function () { };\r\n/**\r\n * 指令类\r\n */\r\nvar Instruction = /** @class */ (function () {\r\n    function Instruction(symbol, desc, pseudo, insPattern, components) {\r\n        this._symbol = symbol;\r\n        this._desc = desc;\r\n        this._pseudo = pseudo;\r\n        this._insPattern = insPattern;\r\n        this._components = components.map(function (x) { return ({\r\n            lBit: x.lBit,\r\n            rBit: x.rBit,\r\n            desc: x.desc,\r\n            toBinary: x.toBinary,\r\n            type: x.type,\r\n            val: x.val,\r\n        }); });\r\n    }\r\n    Instruction.newInstance = function (baseOn) {\r\n        return new Instruction(baseOn.symbol, baseOn.desc, baseOn.pseudo, baseOn.insPattern, baseOn.components);\r\n    };\r\n    Object.defineProperty(Instruction.prototype, \"symbol\", {\r\n        get: function () {\r\n            return this._symbol;\r\n        },\r\n        set: function (symbol) {\r\n            this._symbol = symbol;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Instruction.prototype, \"desc\", {\r\n        get: function () {\r\n            return this._desc;\r\n        },\r\n        set: function (desc) {\r\n            this._desc = desc;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Instruction.prototype, \"pseudo\", {\r\n        get: function () {\r\n            return this._pseudo;\r\n        },\r\n        set: function (pseudo) {\r\n            this._pseudo = pseudo;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Instruction.prototype, \"insPattern\", {\r\n        get: function () {\r\n            return this._insPattern;\r\n        },\r\n        set: function (insPattern) {\r\n            this._insPattern = insPattern;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Instruction.prototype, \"components\", {\r\n        get: function () {\r\n            return this._components;\r\n        },\r\n        set: function (components) {\r\n            this._components = components;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * 设置指令组分\r\n     */\r\n    Instruction.prototype.setComponent = function (desc, val) {\r\n        var index = this._components.findIndex(function (v) { return v.desc == desc; });\r\n        utils_1.assert(index !== -1, \"\\u672A\\u77E5\\u7684\\u6307\\u4EE4\\u7EC4\\u5206: \" + desc);\r\n        this._components[index].val = val;\r\n    };\r\n    /**\r\n     * 指令转二进制\r\n     */\r\n    Instruction.prototype.toBinary = function () {\r\n        utils_1.assert(!this._components.some(function (v) { return !v.val.trim(); }), '尝试将不完整的指令转为2或16进制。');\r\n        return this._components.map(function (v) { return v.val; }).join('');\r\n    };\r\n    /**\r\n     * 指令转十六进制\r\n     */\r\n    Instruction.prototype.toHex = function (zeroX) {\r\n        if (zeroX === void 0) { zeroX = true; }\r\n        return utils_1.binToHex(this.toBinary(), zeroX);\r\n    };\r\n    return Instruction;\r\n}());\r\nexports.Instruction = Instruction;\r\n/**\r\n * Minisys指令集\r\n */\r\nexports.MinisysInstructions = (function () {\r\n    var _MinisysInstructions = [];\r\n    // 新增指令\r\n    function newInstruction(symbol, desc, pseudo, insPattern, components) {\r\n        _MinisysInstructions.push(new Instruction(symbol, desc, pseudo, insPattern, components.map(function (x) { return ({\r\n            lBit: x[0],\r\n            rBit: x[1],\r\n            desc: x[2],\r\n            toBinary: x[3],\r\n            type: x[4],\r\n            val: x[5],\r\n        }); })));\r\n    }\r\n    /**\r\n     * 获取指令正则模式\r\n     * @param params 汇编指令的参数个数\r\n     */\r\n    function paramPattern(num) {\r\n        if (num < 1) {\r\n            return /^$/;\r\n        }\r\n        else {\r\n            // prettier-ignore\r\n            return new RegExp('^' + Array(num).fill(String.raw(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"([w$-]+)\"], [\"([\\\\w$-]+)\"])))).join(',') + '$');\r\n        }\r\n    }\r\n    // =================== R型指令 ===================\r\n    newInstruction('add', '按字加法', '(rd)←(rs)+(rt)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '100000'],\r\n    ]);\r\n    newInstruction('addu', '无符号加', '(rd)←(rs)+(rt)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '100001'],\r\n    ]);\r\n    newInstruction('sub', '按字减法', '(rd)←(rs)-(rt)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '100010'],\r\n    ]);\r\n    newInstruction('subu', '无符号减', '(rd)←(rs)-(rt)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '100011'],\r\n    ]);\r\n    newInstruction('and', '按位与', '(rd)←(rs)&(rt)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '100100'],\r\n    ]);\r\n    newInstruction('mult', '按字乘法', '(HI,LO)←(rs)*(rt)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 6, 'rd+shamt', noop, 'fixed', '0000000000'],\r\n        [5, 0, 'func', noop, 'fixed', '011000'],\r\n    ]);\r\n    newInstruction('multu', '无符号乘', '(HI,LO)←(rs)*(rt)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 6, 'rd+shamt', noop, 'fixed', '0000000000'],\r\n        [5, 0, 'func', noop, 'fixed', '011001'],\r\n    ]);\r\n    newInstruction('div', '除法', '(HI)←(rs)%(rt), (LO)←(rs)/(rt)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 6, 'rd+shamt', noop, 'fixed', '0000000000'],\r\n        [5, 0, 'func', noop, 'fixed', '011010'],\r\n    ]);\r\n    newInstruction('divu', '无符号除', '(HI)←(rs)%(rt), (LO)←(rs)/(rt)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 6, 'rd+shamt', noop, 'fixed', '0000000000'],\r\n        [5, 0, 'func', noop, 'fixed', '011011'],\r\n    ]);\r\n    newInstruction('mfhi', '取HI', '(rd)←(HI)', paramPattern(1), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 16, 'rs+rt', noop, 'fixed', '0000000000'],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '010000'],\r\n    ]);\r\n    newInstruction('mflo', '取LO', '(rd)←(LO)', paramPattern(1), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 16, 'rs+rt', noop, 'fixed', '0000000000'],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '010010'],\r\n    ]);\r\n    newInstruction('mthi', '存HI', '(HI)←(rs)', paramPattern(1), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 6, 'rt+rd+shamt', noop, 'fixed', '000000000000000'],\r\n        [5, 0, 'func', noop, 'fixed', '010001'],\r\n    ]);\r\n    newInstruction('mtlo', '存LO', '(LO)←(rs)', paramPattern(1), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 6, 'rt+rd+shamt', noop, 'fixed', '000000000000000'],\r\n        [5, 0, 'func', noop, 'fixed', '010011'],\r\n    ]);\r\n    // 注意MFC0和MTC0的特殊性\r\n    newInstruction('mfc0', '取C0', '(rt)=由(rd)和sel确定的C0寄存器的值', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '010000'],\r\n        [25, 21, 'rs', noop, 'fixed', '00000'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', function () { return utils_1.literalToBin(RegExp.$3, 6); }, 'c0sel', ''],\r\n    ]);\r\n    newInstruction('mtc0', '存C0', '由(rd)和sel确定的C0寄存器的值=(rt)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '010000'],\r\n        [25, 21, 'rs', noop, 'fixed', '00100'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', function () { return utils_1.literalToBin(RegExp.$3, 6); }, 'c0sel', ''],\r\n    ]);\r\n    newInstruction('or', '按位或', '(rd)←(rs)|(rt)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '100101'],\r\n    ]);\r\n    newInstruction('xor', '按位异或', '(rd)←(rs)^(rt)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '100110'],\r\n    ]);\r\n    newInstruction('nor', '按位或非', '(rd)←~((rs)|(rt))', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '100111'],\r\n    ]);\r\n    newInstruction('slt', '有符号比较', 'if (rs<rt) rd=1 else rd=0', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '101010'],\r\n    ]);\r\n    newInstruction('sltu', '无符号比较', 'if (rs<rt) rd=1 else rd=0', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '101011'],\r\n    ]);\r\n    newInstruction('sll', '逻辑左移', '(rd)←(rt)<<shamt', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', noop, 'fixed', '00000'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', function () { return utils_1.literalToBin(RegExp.$3, 5); }, 'shamt', ''],\r\n        [5, 0, 'func', noop, 'fixed', '000000'],\r\n    ]);\r\n    newInstruction('srl', '逻辑右移', '(rd)←(rt)>>_L shamt', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', noop, 'fixed', '00000'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', function () { return utils_1.literalToBin(RegExp.$3, 5); }, 'shamt', ''],\r\n        [5, 0, 'func', noop, 'fixed', '000010'],\r\n    ]);\r\n    newInstruction('sra', '算术右移', '(rd)←(rt)>>_A shamt', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', noop, 'fixed', '00000'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', function () { return utils_1.literalToBin(RegExp.$3, 5); }, 'shamt', ''],\r\n        [5, 0, 'func', noop, 'fixed', '000011'],\r\n    ]);\r\n    newInstruction('sllv', '逻辑左移V', '(rd)←(rt)<<(rs)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '000100'],\r\n    ]);\r\n    newInstruction('srlv', '逻辑右移V', '(rd)←(rt)>>_L (rs)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '000110'],\r\n    ]);\r\n    newInstruction('srav', '算术右移V', '(rd)←(rt)>>_L (rs)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '000111'],\r\n    ]);\r\n    newInstruction('jr', '无条件跳转（寄存器）', '(PC)←(rs)', paramPattern(1), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 6, 'rt+rd+shamt', noop, 'fixed', '000000000000000'],\r\n        [5, 0, 'func', noop, 'fixed', '001000'],\r\n    ]);\r\n    newInstruction('jalr', '暂存下条后跳转（寄存器）', '(rd)=(PC)+4,(PC)←(rs)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', noop, 'fixed', '00000'],\r\n        [15, 11, 'rd', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [10, 6, 'shamt', noop, 'fixed', '00000'],\r\n        [5, 0, 'func', noop, 'fixed', '001001'],\r\n    ]);\r\n    newInstruction('break', '断点异常', '断点异常', paramPattern(1), [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 6, 'code', function () { return utils_1.literalToBin(RegExp.$1, 20); }, 'code', ''],\r\n        [5, 0, 'func', noop, 'fixed', '001101'],\r\n    ]);\r\n    newInstruction('syscall', '系统调用', '系统调用', /^([\\w$-]+)?$/, [\r\n        [31, 26, 'op', noop, 'fixed', '000000'],\r\n        [25, 6, 'code', function () { return utils_1.literalToBin(RegExp.$1.trim() ? RegExp.$1 : '0', 20); }, 'code', ''],\r\n        [5, 0, 'func', noop, 'fixed', '001100'],\r\n    ]);\r\n    newInstruction('eret', '从中断或者异常中返回', '从中断或者异常中返回', paramPattern(0), [\r\n        [31, 26, 'op', noop, 'fixed', '010000'],\r\n        [25, 6, 'rs+rt+rd+shamt', noop, 'fixed', '10000000000000000000'],\r\n        [5, 0, 'func', noop, 'fixed', '011000'],\r\n    ]);\r\n    // =================== I型指令 ===================\r\n    newInstruction('addi', '加立即数', '(rt)←(rs)+(sign-extend)immediate', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '001000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16, true).slice(-16); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('addiu', '无符号加立即数', '(rt)←(rs)+(sign-extend)immediate', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '001001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16, true).slice(-16); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('andi', '按位与立即数', '(rt)←(rs)&(zero-extend)immediate', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '001100'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16).slice(-16); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('ori', '按位或立即数', '(rt)←(rs)|(zero-extend)immediate', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '001101'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16).slice(-16); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('xori', '按位异或立即数', '(rt)←(rs)^(zero-extend)immediate', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '001110'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16).slice(-16); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('lui', '取立即数高16位', '(rt)←immediate<<16 & 0FFFF0000H', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '001111'],\r\n        [25, 21, 'rs', noop, 'fixed', '00000'],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$2, 16, true).slice(-16); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('lb', '取字节', '(rt)←(Sign-Extend)Memory[(rs)+(sign_extend)offset]', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', noop, 'fixed', '100000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true).slice(-16); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('lbu', '取无符号字节', '(rt)←(Zero-Extend)Memory[(rs)+(sign_extend)offset]', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', noop, 'fixed', '100100'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true).slice(-16); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('lh', '取半字', '(rt)←(Sign-Extend)Memory[(rs)+(sign_extend)offset]', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', noop, 'fixed', '100001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true).slice(-16); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('lhu', '取无符号半字', '(rt)←(Zero-Extend)Memory[(rs)+(sign_extend)offset]', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', noop, 'fixed', '100101'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true).slice(-16); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('sb', '存字节', 'Memory[(rs)+(sign_extend)offset]←(rt)7..0', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', noop, 'fixed', '101000'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true).slice(-16); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('sh', '存半字', 'Memory[(rs)+(sign_extend)offset]←(rt)15..0', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', noop, 'fixed', '101001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true).slice(-16); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('lw', '取字', '(rt)←Memory[(rs)+(sign_extend)offset]', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', noop, 'fixed', '100011'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true).slice(-16); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('sw', '存字', 'Memory[(rs)+(sign_extend)offset]←(rt)', /^([\\w$-]+),([\\w-]+)\\(([\\w$-]+)\\)$/, [\r\n        [31, 26, 'op', noop, 'fixed', '101011'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$3); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.varToAddrBin(RegExp.$2, 16, true).slice(-16); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('beq', '相等分支', 'if ((rt)=(rs)) then (PC)←(PC)+4+((Sign-Extend)offset<<2)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000100'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$3, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bne', '不等分支', 'if ((rt)≠(rs)) then (PC)←(PC)+4+((Sign-Extend)offset<<2)', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '000101'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$3, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bgez', '大于等于0分支', 'if ((rs)≥0) then (PC)←(PC)+4+((Sign-Extend)offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', noop, 'fixed', '00001'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bgtz', '大于0分支', 'if ((rs)＞0) then (PC)←(PC)+4+((Sign-Extend)offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000111'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', noop, 'fixed', '00000'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('blez', '小于等于0分支', 'if ((rs)≤0) then (PC)←(PC)+4+((Sign-Extend)offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000110'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', noop, 'fixed', '00000'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bltz', '小于0分支', 'if ((rs)＜0) then (PC)←(PC)+4+((Sign-Extend) offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', noop, 'fixed', '00000'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bgezal', '大于等于0分支（Link）', 'if ((rs)≥0) then ($31)←(PC)+4,(PC)←(PC)+4+((Sign-Extend) offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', noop, 'fixed', '10001'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('bltzal', '小于0分支（Link）', 'if ((rs)＜0) then ($31)←(PC)+4,(PC)←(PC)+4+((Sign-Extend) offset<<2)', paramPattern(2), [\r\n        [31, 26, 'op', noop, 'fixed', '000001'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [20, 16, 'rt', noop, 'fixed', '10000'],\r\n        [15, 0, 'offset', function () { return utils_1.labelToBin(RegExp.$2, 18, true, true).slice(-18, -2); }, 'offset', ''],\r\n    ]);\r\n    newInstruction('slti', '小于立即数时Set', 'if ((rs)<(Sign-Extend)immediate) then (rt)←1; else (rt)←0', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '001010'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16, true); }, 'immed', ''],\r\n    ]);\r\n    newInstruction('sltiu', '小于立即数时Set（无符号）', 'if ((rs)<(Zero-Extend)immediate) then (rt)←1; else (rt)←0', paramPattern(3), [\r\n        [31, 26, 'op', noop, 'fixed', '001011'],\r\n        [25, 21, 'rs', function () { return register_1.regToBin(RegExp.$2); }, 'reg', ''],\r\n        [20, 16, 'rt', function () { return register_1.regToBin(RegExp.$1); }, 'reg', ''],\r\n        [15, 0, 'immediate', function () { return utils_1.literalToBin(RegExp.$3, 16); }, 'immed', ''],\r\n    ]);\r\n    // =================== J型指令 ===================\r\n    newInstruction('j', '无条件跳转', '(PC)←((Zero-Extend)address<<2)', paramPattern(1), [\r\n        [31, 26, 'op', noop, 'fixed', '000010'],\r\n        [25, 0, 'target', function () { return utils_1.labelToBin(RegExp.$1, 28, false).slice(-28, -2); }, 'addr', ''],\r\n    ]);\r\n    newInstruction('jal', '暂存下条后跳转（立即数）', '($31)←(PC)+4; (PC)←((Zero-Extend)address<<2),', paramPattern(1), [\r\n        [31, 26, 'op', noop, 'fixed', '000011'],\r\n        [25, 0, 'target', function () { return utils_1.labelToBin(RegExp.$1, 28, false).slice(-28, -2); }, 'addr', ''],\r\n    ]);\r\n    // =================== NOP指令 ===================\r\n    newInstruction('nop', '空转指令', 'do nothing', paramPattern(0), [[31, 0, 'NOP', noop, 'fixed', '0'.repeat(32)]]);\r\n    return _MinisysInstructions;\r\n})();\r\nvar templateObject_1;\r\n\n\n//# sourceURL=webpack:///./package/instruction.ts?");

/***/ }),

/***/ "./package/macro.ts":
/*!**************************!*\
  !*** ./package/macro.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys宏指令\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.expansionRules = void 0;\r\nexports.expansionRules = {\r\n    push: {\r\n        pattern: /^push\\s+(\\$\\w{1,2})$/i,\r\n        replacer: function () { return ['addi $sp, $sp, -4', \"sw \" + RegExp.$1 + \", 0($sp)\"]; },\r\n    },\r\n    pop: {\r\n        pattern: /^pop\\s+(\\$\\w{1,2})$/i,\r\n        replacer: function () { return [\"lw \" + RegExp.$1 + \", 0($sp)\", 'addi $sp, $sp, 4']; },\r\n    },\r\n    // 根据“MiniSys-1A CPU 的寄存器及其约定”，$1（$at）固定用作汇编器的暂时变量\r\n    jg: {\r\n        pattern: /^jg\\s+(\\$\\w{1,2}),\\s+(\\$\\w{1,2}),\\s+(\\w+)$/i,\r\n        replacer: function () { return [\r\n            'addi $sp, $sp, -4',\r\n            'sw $1, 0($sp)',\r\n            \"slt $1, \" + RegExp.$2 + \", \" + RegExp.$1,\r\n            \"bne $1, $0, \" + RegExp.$3,\r\n            'lw $1, 0($sp)',\r\n            'addi $sp, $sp, 4',\r\n        ]; },\r\n    },\r\n    jge: {\r\n        pattern: /^jge\\s+(\\$\\w{1,2}),\\s+(\\$\\w{1,2}),\\s+(\\w+)$/i,\r\n        replacer: function () { return [\r\n            'addi $sp, $sp, -4',\r\n            'sw $1, 0($sp)',\r\n            \"slt $1, \" + RegExp.$1 + \", \" + RegExp.$2,\r\n            \"beq $1, $0, \" + RegExp.$3,\r\n            'lw $1, 0($sp)',\r\n            'addi $sp, $sp, 4',\r\n        ]; },\r\n    },\r\n    jl: {\r\n        pattern: /^jl\\s+(\\$\\w{1,2}),\\s+(\\$\\w{1,2}),\\s+(\\w+)$/i,\r\n        replacer: function () { return [\r\n            'addi $sp, $sp, -4',\r\n            'sw $1, 0($sp)',\r\n            \"slt $1, \" + RegExp.$1 + \", \" + RegExp.$2,\r\n            \"bne $1, $0, \" + RegExp.$3,\r\n            'lw $1, 0($sp)',\r\n            'addi $sp, $sp, 4',\r\n        ]; },\r\n    },\r\n    jle: {\r\n        pattern: /^jle\\s+(\\$\\w{1,2}),\\s+(\\$\\w{1,2}),\\s+(\\w+)$/i,\r\n        replacer: function () { return [\r\n            'addi $sp, $sp, -4',\r\n            'sw $1, 0($sp)',\r\n            \"slt $1, \" + RegExp.$2 + \", \" + RegExp.$1,\r\n            \"beq $1, $0, \" + RegExp.$3,\r\n            'lw $1, 0($sp)',\r\n            'addi $sp, $sp, 4',\r\n        ]; },\r\n    },\r\n    move: {\r\n        pattern: /^move\\s+(\\$\\w{1,2}),\\s+(\\$\\w{1,2})$/i,\r\n        replacer: function () { return [\"or \" + RegExp.$1 + \", \" + RegExp.$2 + \", $zero\"]; },\r\n    },\r\n};\r\n\n\n//# sourceURL=webpack:///./package/macro.ts?");

/***/ }),

/***/ "./package/register.ts":
/*!*****************************!*\
  !*** ./package/register.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Minisys寄存器定义\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.regToBin = void 0;\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./package/utils.ts\");\r\n// prettier-ignore\r\nvar registerNames = [\r\n    'zero', 'at',\r\n    'v0', 'v1',\r\n    'a0', 'a1', 'a2', 'a3',\r\n    't0', 't1', 't2', 't3', 't4', 't5', 't6', 't7',\r\n    's0', 's1', 's2', 's3', 's4', 's5', 's6', 's7',\r\n    'k0', 'k1',\r\n    'gp', 'sp', 'fp',\r\n    'ra',\r\n];\r\n/**\r\n * 返回寄存器对应的五位二进制号\r\n * @example $1 1 sp $sp\r\n * @warn 请勿在本函数内覆盖RegExp.$x\r\n */\r\nfunction regToBin(reg) {\r\n    reg = reg.replace('$', '').trim();\r\n    var regNumber;\r\n    if (reg.split('').every(function (x) { return '0123456789'.includes(x); })) {\r\n        regNumber = Number(reg);\r\n    }\r\n    else {\r\n        regNumber = registerNames.indexOf(reg);\r\n    }\r\n    utils_1.assert(regNumber >= 0 && regNumber <= 31, \"\\u65E0\\u6548\\u7684\\u5BC4\\u5B58\\u5668: \" + reg);\r\n    return utils_1.decToBin(regNumber, 5);\r\n}\r\nexports.regToBin = regToBin;\r\n\n\n//# sourceURL=webpack:///./package/register.ts?");

/***/ }),

/***/ "./package/utils.ts":
/*!**************************!*\
  !*** ./package/utils.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Utilities\r\n * by Withod, z0gSh1u @ 2020-10\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getOffsetAddr = exports.getOffset = exports.sizeof = exports.serialString = exports.hexToBin = exports.hexToDec = exports.decToHex = exports.binToHex = exports.decToBin = exports.literalToBin = exports.varToAddrBin = exports.labelToBin = exports.assert = void 0;\r\nvar assembler_1 = __webpack_require__(/*! ./assembler */ \"./package/assembler.ts\");\r\n/**\r\n * Ensure `ensure`, else throw `Error(hint)`.\r\n */\r\nfunction assert(ensure, hint) {\r\n    if (!ensure) {\r\n        throw new Error(hint);\r\n    }\r\n}\r\nexports.assert = assert;\r\n/**\r\n * 将label或字面量转换为二进制\r\n * @param label label名称或字面量数字\r\n * @param len 转换后的长度\r\n * @param isOffset 转换而成的是否为相对当前地址的偏移量\r\n * @param signExt 转换后位数不足时是否进行符号扩展，默认采用零扩展\r\n */\r\nfunction labelToBin(label, len, isOffset, signExt) {\r\n    if (signExt === void 0) { signExt = false; }\r\n    try {\r\n        if (!isOffset) {\r\n            return decToBin(parseInt(literalToBin(label, len, signExt), 2) + assembler_1.userAddrOffset, len, signExt).slice(-len);\r\n        }\r\n        else {\r\n            return literalToBin(label, len, signExt).slice(-len);\r\n        }\r\n    }\r\n    catch (e) {\r\n        return literalToBin((assembler_1.getLabelAddr(label) - (isOffset ? assembler_1.getPC() : 0)).toString(), len, isOffset).slice(-len);\r\n    }\r\n}\r\nexports.labelToBin = labelToBin;\r\n/**\r\n * 将变量名或字面量转换为二进制\r\n * @param name 变量名称或字面量数字\r\n * @param len 转换后的长度\r\n * @param signExt 转换后位数不足时是否进行符号扩展，默认采用零扩展\r\n */\r\nfunction varToAddrBin(name, len, signExt) {\r\n    if (signExt === void 0) { signExt = false; }\r\n    try {\r\n        return literalToBin(name, len, signExt).slice(-len);\r\n    }\r\n    catch (_) {\r\n        return literalToBin(assembler_1.getVarAddr(name).toString(), len).slice(-len);\r\n    }\r\n}\r\nexports.varToAddrBin = varToAddrBin;\r\n/**\r\n * 把字面量数字转换为二进制\r\n * @param literal 要转换的字面量数字\r\n * @param len 转换后的最少位数\r\n * @param signExt 转换后位数不足时是否进行符号扩展，默认采用零扩展\r\n * @example 10\r\n * @example 0xabcd\r\n */\r\nfunction literalToBin(literal, len, signExt) {\r\n    if (signExt === void 0) { signExt = false; }\r\n    assert(!isNaN(Number(literal)), \"\\u9519\\u8BEF\\u7684\\u53C2\\u6570\\uFF1A\" + literal);\r\n    if (literal.startsWith('0x')) {\r\n        var num = hexToBin(literal);\r\n        return num.padStart(len, signExt && parseInt(literal, 16) < 0 ? '1' : '0');\r\n    }\r\n    else {\r\n        return decToBin(parseInt(literal), len, signExt);\r\n    }\r\n}\r\nexports.literalToBin = literalToBin;\r\n/**\r\n * 将十进制数转为二进制，用pad补齐到len位，支持负数\r\n */\r\nfunction decToBin(dec, len, signExt) {\r\n    if (signExt === void 0) { signExt = false; }\r\n    var num = '';\r\n    if (dec < 0) {\r\n        // 算补码\r\n        num = (-dec - 1)\r\n            .toString(2)\r\n            .split('')\r\n            .map(function (v) { return String.fromCharCode(v.charCodeAt(0) ^ 1); })\r\n            .join('');\r\n    }\r\n    else {\r\n        num = dec.toString(2);\r\n    }\r\n    return num.padStart(len, signExt && dec < 0 ? '1' : '0');\r\n}\r\nexports.decToBin = decToBin;\r\n/**\r\n * 将4n位二进制转为n位十六进制\r\n */\r\nfunction binToHex(bin, zeroX) {\r\n    if (zeroX === void 0) { zeroX = true; }\r\n    if (bin.length % 4 !== 0) {\r\n        throw new Error('二进制位数不为4的倍数。');\r\n    }\r\n    return (['', '0x'][Number(zeroX)] +\r\n        bin\r\n            .match(/\\d{4}/g) // [1000, 1000]\r\n            .map(function (v) { return '0123456789abcdef'.charAt(parseInt(v, 2)); })\r\n            .join(''));\r\n}\r\nexports.binToHex = binToHex;\r\n/**\r\n * 将十进制数转为十六进制，十进制数会先被转换为4n位二进制\r\n */\r\nfunction decToHex(dec, len, zeroX) {\r\n    if (zeroX === void 0) { zeroX = true; }\r\n    return binToHex(decToBin(dec, len, false), zeroX);\r\n}\r\nexports.decToHex = decToHex;\r\n/**\r\n * 十六进制转十进制\r\n */\r\nfunction hexToDec(hex) {\r\n    return parseInt(hex, 16);\r\n}\r\nexports.hexToDec = hexToDec;\r\n/**\r\n * 将十六进制每位转换为4位二进制，参数带不带0x头都可以\r\n */\r\nfunction hexToBin(hex) {\r\n    if (hex.startsWith('0x')) {\r\n        hex = hex.substr(2);\r\n    }\r\n    var table = Array(16)\r\n        .fill('')\r\n        .map(function (_, i) { return decToBin(i, 4, false); });\r\n    var res = '';\r\n    hex.split('').forEach(function (v) {\r\n        res += table['0123456789abcdef'.indexOf(v)];\r\n    });\r\n    return res;\r\n}\r\nexports.hexToBin = hexToBin;\r\n/**\r\n * 去除一串字符串中的全部空格\r\n */\r\nfunction serialString(bin) {\r\n    return bin.replace(/\\s+/g, '');\r\n}\r\nexports.serialString = serialString;\r\n/**\r\n * 获取变量组分或指令占用的字节数\r\n */\r\nfunction sizeof(type) {\r\n    var size = {\r\n        byte: 1,\r\n        half: 2,\r\n        word: 4,\r\n        space: 1,\r\n        ascii: 1,\r\n        ins: 4,\r\n    }[type] || -1;\r\n    assert(size !== -1, \"\\u9519\\u8BEF\\u7684\\u53D8\\u91CF\\u7C7B\\u578B\\uFF1A\" + type);\r\n    return size;\r\n}\r\nexports.sizeof = sizeof;\r\n/**\r\n * 算地址偏移量\r\n */\r\nfunction getOffset(holder) {\r\n    return ((holder.byte || 0) * sizeof('byte') +\r\n        (holder.half || 0) * sizeof('half') +\r\n        (holder.word || 0) * sizeof('word') +\r\n        (holder.ascii || 0) * sizeof('ascii') +\r\n        (holder.space || 0) +\r\n        (holder.ins || 0) * sizeof('word'));\r\n}\r\nexports.getOffset = getOffset;\r\n/**\r\n * 算偏移后的地址\r\n * @param baseAddr 基地址，十六进制或十进制\r\n */\r\nfunction getOffsetAddr(baseAddr, offsetBit) {\r\n    var base = baseAddr.startsWith('0x') ? hexToDec(baseAddr) : Number(baseAddr);\r\n    return base + offsetBit;\r\n}\r\nexports.getOffsetAddr = getOffsetAddr;\r\n\n\n//# sourceURL=webpack:///./package/utils.ts?");

/***/ })

/******/ });